# coding: utf-8

"""
    API Manager API v1.3

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.3.0
    Contact: support@axway.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from apim_swagger_client.api_client import ApiClient


class APIProxyRegistrationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def proxies_export_id_get(self, id, filename, **kwargs):  # noqa: E501
        """Downloads an API export.  # noqa: E501

        The API export is produced from [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If __filename__ is supplied, the download will use it as the `Content-Disposition` filename attachment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_export_id_get(id, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The export identifier. (required)
        :param str filename: The export will be downloaded using a Content-Dispostion using the supplied filename (required)
        :return: APIPromotion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_export_id_get_with_http_info(id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_export_id_get_with_http_info(id, filename, **kwargs)  # noqa: E501
            return data

    def proxies_export_id_get_with_http_info(self, id, filename, **kwargs):  # noqa: E501
        """Downloads an API export.  # noqa: E501

        The API export is produced from [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If __filename__ is supplied, the download will use it as the `Content-Disposition` filename attachment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_export_id_get_with_http_info(id, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The export identifier. (required)
        :param str filename: The export will be downloaded using a Content-Dispostion using the supplied filename (required)
        :return: APIPromotion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_export_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_export_id_get`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `proxies_export_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/export/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPromotion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_export_post(self, id, password, filename, **kwargs):  # noqa: E501
        """Creates an API export.  # noqa: E501

        Creates an export for use in promoting the API to a new environment.  The export contains the frontend [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) that are required for the frontend API.  If **password** is supplied, the exported file will be encrypted with the password.  If successful, returns **201 Created**, and the HTTP `Location` header contain the of the URL of the export. The export is temporary, and may only be downloaded once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_export_post(id, password, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: The frontend API identifier(s) to export. (required)
        :param str password: Encrypts the list of API using the password. (required)
        :param str filename: Optional filename to use in response. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_export_post_with_http_info(id, password, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_export_post_with_http_info(id, password, filename, **kwargs)  # noqa: E501
            return data

    def proxies_export_post_with_http_info(self, id, password, filename, **kwargs):  # noqa: E501
        """Creates an API export.  # noqa: E501

        Creates an export for use in promoting the API to a new environment.  The export contains the frontend [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) that are required for the frontend API.  If **password** is supplied, the exported file will be encrypted with the password.  If successful, returns **201 Created**, and the HTTP `Location` header contain the of the URL of the export. The export is temporary, and may only be downloaded once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_export_post_with_http_info(id, password, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: The frontend API identifier(s) to export. (required)
        :param str password: Encrypts the list of API using the password. (required)
        :param str filename: Optional filename to use in response. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'password', 'filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_export_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_export_post`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `proxies_export_post`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `proxies_export_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
            collection_formats['id'] = 'multi'  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'filename' in params:
            form_params.append(('filename', params['filename']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_get(self, **kwargs):  # noqa: E501
        """Queries a list of frontend API.  # noqa: E501

        Returns a list of API that are visible to the authenticated user.  The list of API can be filtered using the expression: field=__field__&op=__op__&value=__value__.  Optionally, you can add a logical operation for all expressions, using the form: &lop=AND|OR.  By default, the logical operation is AND.  Multiple expression filters can be used, specifying field, op, and value for each filter. The __field__ is one of:  name :      The name of the API  apiid :      Matches the API if the API is virtualized from the specified backend API  createdOn :      The date the virtualized API was created on, time in ms, e.g.: 1372755998542  deprecated :      The deprecated state of the API, one of: true or false  retired :      The retired state of the API, one of: true or false  state :      The API's state, one of: unpublished, pending, or published  path :      The path that services this virtualized API.  The __op__ is an operation and is one of:  eq :      Equal  ne :      Not equal  gt :      Greater than  lt :      Less than  ge :      Greater than or equal  le :      Less than or equal  like :      Like  gele :      Greater than or equal to, and less than or equal to; the __value__ should be a lower-minimum and upper-maximum separated by comma, e.g: value=5,10  The __value__ will be compared against the __field__, according to the supplied __op__.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] field: Filter field name.
        :param list[str] op: Filter operation.
        :param list[str] value: Filter value
        :return: list[VirtualizedAPI]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.proxies_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def proxies_get_with_http_info(self, **kwargs):  # noqa: E501
        """Queries a list of frontend API.  # noqa: E501

        Returns a list of API that are visible to the authenticated user.  The list of API can be filtered using the expression: field=__field__&op=__op__&value=__value__.  Optionally, you can add a logical operation for all expressions, using the form: &lop=AND|OR.  By default, the logical operation is AND.  Multiple expression filters can be used, specifying field, op, and value for each filter. The __field__ is one of:  name :      The name of the API  apiid :      Matches the API if the API is virtualized from the specified backend API  createdOn :      The date the virtualized API was created on, time in ms, e.g.: 1372755998542  deprecated :      The deprecated state of the API, one of: true or false  retired :      The retired state of the API, one of: true or false  state :      The API's state, one of: unpublished, pending, or published  path :      The path that services this virtualized API.  The __op__ is an operation and is one of:  eq :      Equal  ne :      Not equal  gt :      Greater than  lt :      Less than  ge :      Greater than or equal  le :      Less than or equal  like :      Like  gele :      Greater than or equal to, and less than or equal to; the __value__ should be a lower-minimum and upper-maximum separated by comma, e.g: value=5,10  The __value__ will be compared against the __field__, according to the supplied __op__.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] field: Filter field name.
        :param list[str] op: Filter operation.
        :param list[str] value: Filter value
        :return: list[VirtualizedAPI]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['field', 'op', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'field' in params:
            query_params.append(('field', params['field']))  # noqa: E501
            collection_formats['field'] = 'multi'  # noqa: E501
        if 'op' in params:
            query_params.append(('op', params['op']))  # noqa: E501
            collection_formats['op'] = 'multi'  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
            collection_formats['value'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VirtualizedAPI]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_grantaccess_post(self, action, api_id, grant_org_id, grant_api_id, **kwargs):  # noqa: E501
        """Macro function to grant API access.  # noqa: E501

        Function to macro-apply access to selected API.  The access can be granted to organizations or entities having access to specified API. If **action** is _all_orgs_, access will be granted to all organizations; if **action** is _orgs_, access will be granted to the organization(s) specified by **grantOrganizations**; if **action** is _orgs\\_with\\_apis_, access will be granted to the organizations with access to the apis specified by **grantApis**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_grantaccess_post(action, api_id, grant_org_id, grant_api_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Grant action to perform. Possible values are: all\\_orgs, orgs, and orgs\\_with\\_apis. (required)
        :param list[str] api_id: List of API ID to which access will be granted. (required)
        :param list[str] grant_org_id: List of target organization ID to which access to _apiId_ will be granted (action is _orgs_) (required)
        :param list[str] grant_api_id: List of API ID to which access to to _apiId_ will be granted (action is _orgs\\_with\\_apis_). (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_grantaccess_post_with_http_info(action, api_id, grant_org_id, grant_api_id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_grantaccess_post_with_http_info(action, api_id, grant_org_id, grant_api_id, **kwargs)  # noqa: E501
            return data

    def proxies_grantaccess_post_with_http_info(self, action, api_id, grant_org_id, grant_api_id, **kwargs):  # noqa: E501
        """Macro function to grant API access.  # noqa: E501

        Function to macro-apply access to selected API.  The access can be granted to organizations or entities having access to specified API. If **action** is _all_orgs_, access will be granted to all organizations; if **action** is _orgs_, access will be granted to the organization(s) specified by **grantOrganizations**; if **action** is _orgs\\_with\\_apis_, access will be granted to the organizations with access to the apis specified by **grantApis**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_grantaccess_post_with_http_info(action, api_id, grant_org_id, grant_api_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Grant action to perform. Possible values are: all\\_orgs, orgs, and orgs\\_with\\_apis. (required)
        :param list[str] api_id: List of API ID to which access will be granted. (required)
        :param list[str] grant_org_id: List of target organization ID to which access to _apiId_ will be granted (action is _orgs_) (required)
        :param list[str] grant_api_id: List of API ID to which access to to _apiId_ will be granted (action is _orgs\\_with\\_apis_). (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'api_id', 'grant_org_id', 'grant_api_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_grantaccess_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `proxies_grantaccess_post`")  # noqa: E501
        # verify the required parameter 'api_id' is set
        if ('api_id' not in params or
                params['api_id'] is None):
            raise ValueError("Missing the required parameter `api_id` when calling `proxies_grantaccess_post`")  # noqa: E501
        # verify the required parameter 'grant_org_id' is set
        if ('grant_org_id' not in params or
                params['grant_org_id'] is None):
            raise ValueError("Missing the required parameter `grant_org_id` when calling `proxies_grantaccess_post`")  # noqa: E501
        # verify the required parameter 'grant_api_id' is set
        if ('grant_api_id' not in params or
                params['grant_api_id'] is None):
            raise ValueError("Missing the required parameter `grant_api_id` when calling `proxies_grantaccess_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501
        if 'api_id' in params:
            form_params.append(('apiId', params['api_id']))  # noqa: E501
            collection_formats['apiId'] = 'multi'  # noqa: E501
        if 'grant_org_id' in params:
            form_params.append(('grantOrgId', params['grant_org_id']))  # noqa: E501
            collection_formats['grantOrgId'] = 'multi'  # noqa: E501
        if 'grant_api_id' in params:
            form_params.append(('grantApiId', params['grant_api_id']))  # noqa: E501
            collection_formats['grantApiId'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/grantaccess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_applications_get(self, id, **kwargs):  # noqa: E501
        """Gets a list of Applications that have been granted access to the specified frontend API.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_applications_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_applications_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_applications_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_applications_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets a list of Applications that have been granted access to the specified frontend API.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_applications_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_applications_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_applications_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Application]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_delete(self, id, **kwargs):  # noqa: E501
        """Deletes an API proxy.  # noqa: E501

        Deletes an API proxy, removing all API access in the process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Deletes an API proxy.  # noqa: E501

        Deletes an API proxy, removing all API access in the process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_deprecate_post(self, id, **kwargs):  # noqa: E501
        """Deprecates the API.  # noqa: E501

        Only an API Administrator may deprecate an API, and only _published_ API may be deprecated.  When an API is _deprecated_, the API can still be used, but users will be informed that the API has been deprecated.  Optionally, a **retirementDate** may be set which will schedule the API to be automatically retired and removed from use. If specified, the **retirementDate** should be in the ISO-8601 format of yyyy-MM-ddTHH:mm:ssZ (e.g. 2015-01-01T12:00:00Z).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_deprecate_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str retirement_date: Optional API retirement date specified in supported ISO-8601 format.  Set to the past to retire immediately.
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_deprecate_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_deprecate_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_deprecate_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Deprecates the API.  # noqa: E501

        Only an API Administrator may deprecate an API, and only _published_ API may be deprecated.  When an API is _deprecated_, the API can still be used, but users will be informed that the API has been deprecated.  Optionally, a **retirementDate** may be set which will schedule the API to be automatically retired and removed from use. If specified, the **retirementDate** should be in the ISO-8601 format of yyyy-MM-ddTHH:mm:ssZ (e.g. 2015-01-01T12:00:00Z).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_deprecate_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str retirement_date: Optional API retirement date specified in supported ISO-8601 format.  Set to the past to retire immediately.
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'retirement_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_deprecate_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_deprecate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'retirement_date' in params:
            form_params.append(('retirementDate', params['retirement_date']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/deprecate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_get(self, id, **kwargs):  # noqa: E501
        """Gets a frontend API by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets a frontend API by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_image_get(self, id, **kwargs):  # noqa: E501
        """Gets the image for the API.  # noqa: E501

        Returns the jpeg image associated with the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_image_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_image_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_image_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_image_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the image for the API.  # noqa: E501

        Returns the jpeg image associated with the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_image_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_image_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_image_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/jpeg'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/image', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_image_post(self, id, **kwargs):  # noqa: E501
        """Set the image for the frontend API.  # noqa: E501

        Set the jpeg image to be associated with the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_image_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param file file:
        :param str type:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_image_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_image_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_image_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Set the image for the frontend API.  # noqa: E501

        Set the jpeg image to be associated with the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_image_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param file file:
        :param str type:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'file', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_image_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_image_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/image', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_operations_get(self, id, **kwargs):  # noqa: E501
        """Gets a list of methods that are avilable to the API proxy.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: list[VirtualizedAPIMethod]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_operations_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_operations_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_operations_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets a list of methods that are avilable to the API proxy.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: list[VirtualizedAPIMethod]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_operations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_operations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/operations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VirtualizedAPIMethod]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_operations_operation_id_delete(self, id, operation_id, **kwargs):  # noqa: E501
        """Deletes an API method by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_delete(id, operation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_operations_operation_id_delete_with_http_info(id, operation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_operations_operation_id_delete_with_http_info(id, operation_id, **kwargs)  # noqa: E501
            return data

    def proxies_id_operations_operation_id_delete_with_http_info(self, id, operation_id, **kwargs):  # noqa: E501
        """Deletes an API method by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_delete_with_http_info(id, operation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'operation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_operations_operation_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_operations_operation_id_delete`")  # noqa: E501
        # verify the required parameter 'operation_id' is set
        if ('operation_id' not in params or
                params['operation_id'] is None):
            raise ValueError("Missing the required parameter `operation_id` when calling `proxies_id_operations_operation_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'operation_id' in params:
            path_params['operationId'] = params['operation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/operations/{operationId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_operations_operation_id_get(self, id, operation_id, **kwargs):  # noqa: E501
        """Gets an API method by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_get(id, operation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :return: VirtualizedAPIMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_operations_operation_id_get_with_http_info(id, operation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_operations_operation_id_get_with_http_info(id, operation_id, **kwargs)  # noqa: E501
            return data

    def proxies_id_operations_operation_id_get_with_http_info(self, id, operation_id, **kwargs):  # noqa: E501
        """Gets an API method by ID.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_get_with_http_info(id, operation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :return: VirtualizedAPIMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'operation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_operations_operation_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_operations_operation_id_get`")  # noqa: E501
        # verify the required parameter 'operation_id' is set
        if ('operation_id' not in params or
                params['operation_id'] is None):
            raise ValueError("Missing the required parameter `operation_id` when calling `proxies_id_operations_operation_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'operation_id' in params:
            path_params['operationId'] = params['operation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/operations/{operationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPIMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_operations_operation_id_put(self, id, operation_id, body, **kwargs):  # noqa: E501
        """Updates an API proxy operation.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_put(id, operation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :param VirtualizedAPIMethod body: The method to update. (required)
        :return: VirtualizedAPIMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_operations_operation_id_put_with_http_info(id, operation_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_operations_operation_id_put_with_http_info(id, operation_id, body, **kwargs)  # noqa: E501
            return data

    def proxies_id_operations_operation_id_put_with_http_info(self, id, operation_id, body, **kwargs):  # noqa: E501
        """Updates an API proxy operation.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_operations_operation_id_put_with_http_info(id, operation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str operation_id: The frontend API method identifier. (required)
        :param VirtualizedAPIMethod body: The method to update. (required)
        :return: VirtualizedAPIMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'operation_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_operations_operation_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_operations_operation_id_put`")  # noqa: E501
        # verify the required parameter 'operation_id' is set
        if ('operation_id' not in params or
                params['operation_id'] is None):
            raise ValueError("Missing the required parameter `operation_id` when calling `proxies_id_operations_operation_id_put`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `proxies_id_operations_operation_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'operation_id' in params:
            path_params['operationId'] = params['operation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/operations/{operationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPIMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_publish_post(self, id, name, vhost, **kwargs):  # noqa: E501
        """Publish the API.  # noqa: E501

        If called by an API Administrator, then the API state will be _published_, otherwise the API state will be _pending_, and an email notification will be sent to the API Administrators, notifying them of the event. Optionally, on publishing, a new **name** for the API may be specified.  Similarly, an optional **vhost** may be specified.  The **vhost** is an externally resolvable virtual host from which the API will be accessed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_publish_post(id, name, vhost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str name: The name on which to publish this API. (required)
        :param str vhost: The optional virtual host on which to publish this API. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_publish_post_with_http_info(id, name, vhost, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_publish_post_with_http_info(id, name, vhost, **kwargs)  # noqa: E501
            return data

    def proxies_id_publish_post_with_http_info(self, id, name, vhost, **kwargs):  # noqa: E501
        """Publish the API.  # noqa: E501

        If called by an API Administrator, then the API state will be _published_, otherwise the API state will be _pending_, and an email notification will be sent to the API Administrators, notifying them of the event. Optionally, on publishing, a new **name** for the API may be specified.  Similarly, an optional **vhost** may be specified.  The **vhost** is an externally resolvable virtual host from which the API will be accessed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_publish_post_with_http_info(id, name, vhost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param str name: The name on which to publish this API. (required)
        :param str vhost: The optional virtual host on which to publish this API. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'vhost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_publish_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_publish_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `proxies_id_publish_post`")  # noqa: E501
        # verify the required parameter 'vhost' is set
        if ('vhost' not in params or
                params['vhost'] is None):
            raise ValueError("Missing the required parameter `vhost` when calling `proxies_id_publish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'vhost' in params:
            form_params.append(('vhost', params['vhost']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_put(self, id, body, **kwargs):  # noqa: E501
        """Updates an API proxy.  # noqa: E501

        Updates an API proxy definition. Data in this request may include custom properties defined in app.config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_put(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param VirtualizedAPI body: The virtualized API to update (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_put_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_put_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def proxies_id_put_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Updates an API proxy.  # noqa: E501

        Updates an API proxy definition. Data in this request may include custom properties defined in app.config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_put_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :param VirtualizedAPI body: The virtualized API to update (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_put`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `proxies_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_undeprecate_post(self, id, **kwargs):  # noqa: E501
        """Undeprecates the API.  # noqa: E501

        Only an API Administrator may undeprecate an API, and only _published_ API, that are deprecated, may be undeprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_undeprecate_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_undeprecate_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_undeprecate_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_undeprecate_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Undeprecates the API.  # noqa: E501

        Only an API Administrator may undeprecate an API, and only _published_ API, that are deprecated, may be undeprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_undeprecate_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_undeprecate_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_undeprecate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/undeprecate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_id_unpublish_post(self, id, **kwargs):  # noqa: E501
        """Unpublish the API.  # noqa: E501

        Only an API Administrator may unpublish an API.  When an API is _unpublished_, all access to the API is revoked from all applications, and all organizations, save the API development organization that owns the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_unpublish_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_id_unpublish_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_id_unpublish_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def proxies_id_unpublish_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Unpublish the API.  # noqa: E501

        Only an API Administrator may unpublish an API.  When an API is _unpublished_, all access to the API is revoked from all applications, and all organizations, save the API development organization that owns the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_id_unpublish_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The frontend API identifier. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_id_unpublish_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_id_unpublish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/{id}/unpublish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_import_from_url_post(self, organization_id, url, password, **kwargs):  # noqa: E501
        """Imports a previously exported API.  # noqa: E501

        Imports API, previously exported using [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If the API was exported using a password, then the file is encrypted, and a **password** argument must be provided to decrypt.  The import will create  [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) necessary to support the frontend API.  The **url** should be a [data URI scheme](http://en.wikipedia.org/wiki/Data_URI_scheme).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_import_from_url_post(organization_id, url, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_id: The organization identifier. (required)
        :param str url: The data URI. (required)
        :param str password: Optional password to decrypt the import file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_import_from_url_post_with_http_info(organization_id, url, password, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_import_from_url_post_with_http_info(organization_id, url, password, **kwargs)  # noqa: E501
            return data

    def proxies_import_from_url_post_with_http_info(self, organization_id, url, password, **kwargs):  # noqa: E501
        """Imports a previously exported API.  # noqa: E501

        Imports API, previously exported using [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If the API was exported using a password, then the file is encrypted, and a **password** argument must be provided to decrypt.  The import will create  [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) necessary to support the frontend API.  The **url** should be a [data URI scheme](http://en.wikipedia.org/wiki/Data_URI_scheme).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_import_from_url_post_with_http_info(organization_id, url, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_id: The organization identifier. (required)
        :param str url: The data URI. (required)
        :param str password: Optional password to decrypt the import file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'url', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_import_from_url_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params or
                params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `proxies_import_from_url_post`")  # noqa: E501
        # verify the required parameter 'url' is set
        if ('url' not in params or
                params['url'] is None):
            raise ValueError("Missing the required parameter `url` when calling `proxies_import_from_url_post`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `proxies_import_from_url_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'organization_id' in params:
            form_params.append(('organizationId', params['organization_id']))  # noqa: E501
        if 'url' in params:
            form_params.append(('url', params['url']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/importFromUrl', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_import_post(self, organization_id, password, file, **kwargs):  # noqa: E501
        """Imports a previously exported API.  # noqa: E501

        Imports API, previously exported using [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If the API was exported using a password, then the file is encrypted, and a **password** argument must be provided to decrypt.  The import will create  [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) necessary to support the frontend API.  This method is similar to [/importFromUrl](APIProxyRegistration.html#APIProxyRegistrationimportFromUrl), save that this method supports traditional form-based file upload, using `multipart/form-data`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_import_post(organization_id, password, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_id: The organization identifier. (required)
        :param str password: Optional password to decrypt the import file. (required)
        :param file file: The data file to import. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_import_post_with_http_info(organization_id, password, file, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_import_post_with_http_info(organization_id, password, file, **kwargs)  # noqa: E501
            return data

    def proxies_import_post_with_http_info(self, organization_id, password, file, **kwargs):  # noqa: E501
        """Imports a previously exported API.  # noqa: E501

        Imports API, previously exported using [/exportApis](APIProxyRegistration.html#APIProxyRegistrationexportApis).  If the API was exported using a password, then the file is encrypted, and a **password** argument must be provided to decrypt.  The import will create  [VirtualizedAPI](VirtualizedAPI.html), their settings, and all backend [APIDefinition](APIDefinition.html) necessary to support the frontend API.  This method is similar to [/importFromUrl](APIProxyRegistration.html#APIProxyRegistrationimportFromUrl), save that this method supports traditional form-based file upload, using `multipart/form-data`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_import_post_with_http_info(organization_id, password, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_id: The organization identifier. (required)
        :param str password: Optional password to decrypt the import file. (required)
        :param file file: The data file to import. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'password', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_import_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params or
                params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `proxies_import_post`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `proxies_import_post`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `proxies_import_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'organization_id' in params:
            form_params.append(('organizationId', params['organization_id']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_post(self, body, **kwargs):  # noqa: E501
        """Creates a new API proxy from a backend API.  # noqa: E501

        The [VirtualizedAPI apiId](VirtualizedAPI.html#apiId) is required.  If creating the APIas an API administrator, the [VirtualizedAPI organizationId](VirtualizedAPI.html#organizationId) must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VirtualizedAPI body: The frontend API to create. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def proxies_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new API proxy from a backend API.  # noqa: E501

        The [VirtualizedAPI apiId](VirtualizedAPI.html#apiId) is required.  If creating the APIas an API administrator, the [VirtualizedAPI organizationId](VirtualizedAPI.html#organizationId) must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VirtualizedAPI body: The frontend API to create. (required)
        :return: VirtualizedAPI
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `proxies_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualizedAPI',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_promote_post(self, api_id, **kwargs):  # noqa: E501
        """Invokes the internal API promotion policy for the specified API.  # noqa: E501

        In API Manager, API promotion must first be enabled in Settings. Also, in Policy Studio (Server Settings -> API Manager -> API Promotion) a promotion policy must be selected. By default a sample promotion policy is installed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_promote_post(api_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] api_id: The frontend API identifier(s) to promote (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_promote_post_with_http_info(api_id, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_promote_post_with_http_info(api_id, **kwargs)  # noqa: E501
            return data

    def proxies_promote_post_with_http_info(self, api_id, **kwargs):  # noqa: E501
        """Invokes the internal API promotion policy for the specified API.  # noqa: E501

        In API Manager, API promotion must first be enabled in Settings. Also, in Policy Studio (Server Settings -> API Manager -> API Promotion) a promotion policy must be selected. By default a sample promotion policy is installed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_promote_post_with_http_info(api_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] api_id: The frontend API identifier(s) to promote (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_promote_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_id' is set
        if ('api_id' not in params or
                params['api_id'] is None):
            raise ValueError("Missing the required parameter `api_id` when calling `proxies_promote_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'api_id' in params:
            form_params.append(('apiId', params['api_id']))  # noqa: E501
            collection_formats['apiId'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/promote', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def proxies_upgrade_id_post(self, id, upgrade_api_id, deprecate, retire, retirement_date, **kwargs):  # noqa: E501
        """Upgrades an existing frontend API to a newer frontend API.  # noqa: E501

        During an API lifecycle, it is necessary to upgrade users to use a newer frontend API.  The idea being that the old frontend API should be phased-out, and developers should move their applications to use the newer frontend API. This method assigns all organizations and applications the same access to the new frontend API (identified by **upgradeApiId**) that they have to the old API (identified by **id**). Optionally, the old frontend API may be deprecated or retired using **deprecate**, **retire**, or scheduled to be retired using **retirementDate**. If specified, the **retirementDate** should be in the ISO-8601 format of yyyy-MM-ddTHH:mm:ssZ (e.g. 2015-01-01T12:00:00Z).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_upgrade_id_post(id, upgrade_api_id, deprecate, retire, retirement_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str upgrade_api_id: The id of the frontend API which will be used to upgrade this virtualized API (required)
        :param bool deprecate: Specifies whether or not the API being upgraded should be depreated (required)
        :param bool retire: Specifies whether or not the API being upgraded should be retired (required)
        :param str retirement_date: Specifies the retirement date of the the API being upgraded if its being retired (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.proxies_upgrade_id_post_with_http_info(id, upgrade_api_id, deprecate, retire, retirement_date, **kwargs)  # noqa: E501
        else:
            (data) = self.proxies_upgrade_id_post_with_http_info(id, upgrade_api_id, deprecate, retire, retirement_date, **kwargs)  # noqa: E501
            return data

    def proxies_upgrade_id_post_with_http_info(self, id, upgrade_api_id, deprecate, retire, retirement_date, **kwargs):  # noqa: E501
        """Upgrades an existing frontend API to a newer frontend API.  # noqa: E501

        During an API lifecycle, it is necessary to upgrade users to use a newer frontend API.  The idea being that the old frontend API should be phased-out, and developers should move their applications to use the newer frontend API. This method assigns all organizations and applications the same access to the new frontend API (identified by **upgradeApiId**) that they have to the old API (identified by **id**). Optionally, the old frontend API may be deprecated or retired using **deprecate**, **retire**, or scheduled to be retired using **retirementDate**. If specified, the **retirementDate** should be in the ISO-8601 format of yyyy-MM-ddTHH:mm:ssZ (e.g. 2015-01-01T12:00:00Z).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.proxies_upgrade_id_post_with_http_info(id, upgrade_api_id, deprecate, retire, retirement_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str upgrade_api_id: The id of the frontend API which will be used to upgrade this virtualized API (required)
        :param bool deprecate: Specifies whether or not the API being upgraded should be depreated (required)
        :param bool retire: Specifies whether or not the API being upgraded should be retired (required)
        :param str retirement_date: Specifies the retirement date of the the API being upgraded if its being retired (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'upgrade_api_id', 'deprecate', 'retire', 'retirement_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxies_upgrade_id_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `proxies_upgrade_id_post`")  # noqa: E501
        # verify the required parameter 'upgrade_api_id' is set
        if ('upgrade_api_id' not in params or
                params['upgrade_api_id'] is None):
            raise ValueError("Missing the required parameter `upgrade_api_id` when calling `proxies_upgrade_id_post`")  # noqa: E501
        # verify the required parameter 'deprecate' is set
        if ('deprecate' not in params or
                params['deprecate'] is None):
            raise ValueError("Missing the required parameter `deprecate` when calling `proxies_upgrade_id_post`")  # noqa: E501
        # verify the required parameter 'retire' is set
        if ('retire' not in params or
                params['retire'] is None):
            raise ValueError("Missing the required parameter `retire` when calling `proxies_upgrade_id_post`")  # noqa: E501
        # verify the required parameter 'retirement_date' is set
        if ('retirement_date' not in params or
                params['retirement_date'] is None):
            raise ValueError("Missing the required parameter `retirement_date` when calling `proxies_upgrade_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'upgrade_api_id' in params:
            form_params.append(('upgradeApiId', params['upgrade_api_id']))  # noqa: E501
        if 'deprecate' in params:
            form_params.append(('deprecate', params['deprecate']))  # noqa: E501
        if 'retire' in params:
            form_params.append(('retire', params['retire']))  # noqa: E501
        if 'retirement_date' in params:
            form_params.append(('retirementDate', params['retirement_date']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic']  # noqa: E501

        return self.api_client.call_api(
            '/proxies/upgrade/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
