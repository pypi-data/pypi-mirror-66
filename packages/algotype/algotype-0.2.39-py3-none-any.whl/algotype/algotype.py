#!/usr/bin/python3
# -*- coding: utf-8 -*-

# author: Marek Ryćko
__author__ = 'Marek Ryćko <marek@do.com.pl>'

'''
Execute selected steps of transforming font data.

The steps include:

***
generating eps files and an oti file
from a group of mp files

log file (generated by metapost)
fls file (report of inputs)
out file (if standard output goes to a file, not a screen)
are generated and put to a specified directory

05.02.2019 05:11:50
start

***
generating fea file from oti file
translating the oti file to a fea file

19.02.2019 17:16:23
start: coded in Python from bat file and bash script

***
generating fonts (oti and type1, the last containing pfb, afm, pfm files)

21.02.2019 03:51:37
attempts to eliminate python2 (not yet possible, due to fontforge restrictions)

'''

# standard library:
import argparse
import json
import re
# for joining paths:
import os

# modules of Algotype:
import algotype.config as config
import algotype.steps as steps_lib
import algotype.log_lib as log_lib
import algotype.meta as meta
import algotype.rename_lib as rename_lib

# ------------------------------------------------------------------------------
# string representations of some displayed and/or logged messages:
# ------------------------------------------------------------------------------
def repr_identifiers_list(sl):
    '''
    For a (short) string list sl return a string representation.
    '''
    if len(sl) == 0:
        res = 'None'
    else:
        # make sure elements are strings and join using comma-space:
        res = ', '.join([str(s) for s in sl])
    return res

def repr_list_of_lists(j):
    '''
    represent the json structure j
    being a list of lists
    as a json string, as readable as possible
    '''
    # config: the indent string:
    indent = 4 * ' '
    # collect the result list:
    rl = []
    for e in j:
        s = json.dumps(e, ensure_ascii=False)
        rl.append(s)
    res = '[\n' + indent + (',\n' + indent).join(rl) + '\n]'
    return res
    
# ------------------------------------------------------------------------------
# prepare the structured parameter
# to the tex step
# ------------------------------------------------------------------------------
def conf_to_tex_par(conf, font_basenames):

    # prepare a list of cs encodings from the (possibly) defined list:
    enc_with_sc = re.split(r'\s*\,\s*', conf['enc_with_sc']) \
        if 'enc_with_sc' in conf else []
    enc_without_sc = re.split(r'\s*\,\s*', conf['enc_without_sc']) \
        if 'enc_without_sc' in conf else []
    # enc_with_sc is something like ['cs, ec, l7x, qx, rm, t5, yy']
    # enc_without_sc is something like ['ts1']
    log_lib.info(f"encodings with sc: {repr_identifiers_list(enc_with_sc)}")
    log_lib.info(f"encodings without sc: {repr_identifiers_list(enc_without_sc)}")
    
    tex_par = []
    for enc in enc_with_sc:
        tex_par.append([enc])
        tex_par.append([enc, 'sc'])
    for enc in enc_without_sc:
        tex_par.append([enc])
    return tex_par

# ------------------------------------------------------------------------------
# run:
# ------------------------------------------------------------------------------

def dispatcher(conf, step, tex_par, renaming, json_font_fn):
    '''
    execute a step 
    identified by the string step
    '''
    log_lib.debug_separator(element='-')
    log_lib.info(f"{'-' * 30} step {step}:")
    
    # at the stage after json_font -- read the json_font structure:
    if step in ('otf', 'tex'):
        json_font = read_json_font(json_font_fn)

    if step == 'eps':
        # generating eps files and oti file:
        steps_lib.step_eps_oti(conf, rename=True)
    elif step == 'lm_eps':
        # generating eps files:
        steps_lib.step_eps_oti(conf, rename=False)
    elif step == 'fea':
        # generate fea file (from an oti file):
        steps_lib.step_fea(conf)
    elif step == 'lm_fea':
        # generate fea file (from an oti file), LM-style:
        steps_lib.step_lm_fea(conf)
    elif step == 'json_font':
        # generate fonts (otf and pfb):
        steps_lib.step_generate_json_font(conf)
    elif step == 'otf':
        # generate fonts (otf and pfb):
        steps_lib.step_generate_fonts_otf_pfb(conf, json_font)
    elif step == 'tex':
        # generate tfm, enc and map files:
        # ~ steps_lib.step_tex(conf, par=par_3)
        steps_lib.step_tex(conf, tex_par, renaming, json_font)
        
def one(conf, steps, tex_par, renaming, json_font_fn):
    for step in steps:
        dispatcher(conf, step, tex_par, renaming, json_font_fn)
        
def read_json_font(json_font_fn):
    '''
    If json font exists at the place indicated by conf, then read it.
    '''
    try:
        with open(json_font_fn, 'r') as fh:
            json_font_str = fh.read()
        res = json.loads(json_font_str)
    except:
        log_lib.error(f"cannot read json_font file: {json_font_fn}")
        res = None
    return res
    
def json_font_filename(conf):
    res = os.path.join(conf['json_dir'], conf['fb'] + '_font.json')
    return res


def main():
    # ------------------------------------------------------------------------------
    # determine what config files to read:
    # ------------------------------------------------------------------------------

    description = '''Read config files and execute typographic algorithms
    according to the parameters in the sum (concatenation) of the config files.'''

    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('configs', metavar='config', type=str, nargs='+',
        help='name of a config file (there may be multiple config files)')

    args = parser.parse_args()
    configs = args.configs

    # ------------------------------------------------------------------------------
    # start logs and report to debug log
    # ------------------------------------------------------------------------------
    log_lib.start_log(log_name=None, log_level='debug', screen_level='info')

    # Greeting:
    log_lib.debug_separator()
    log_lib.info(f"Algotype. Algorythmic font creation system. Version: Alpha {meta.version}")
    
    # putting call parameters to the debugd file:
    log_lib.debug(f"Algotype call parameters:")
    for arg_parameter in args.configs:
        log_lib.debug(f"    {arg_parameter}")
    
    # ------------------------------------------------------------------------------
    # translate config files to config structure(s):
    # ------------------------------------------------------------------------------
    
    conf = config.prepare(configs)

    # ~ s2 = json.dumps(conf, indent=4, ensure_ascii=False) 
    # ~ log_lib.debug(s2)

    log_lib.info(f"{'-' * 30} parameters of the processing:")

    # prepare a list of styles from the defined family:
    sty = re.split(r'\s*\,\s*', conf['styles'])
    # sty is something like ['b', 'r']
    # prepare a list of fb-s for the styles
    font_basenames = [conf['gen_name'] + s for s in sty]
    log_lib.info(f"font basenames: {repr_identifiers_list(font_basenames)}")

    # prepare a list of steps from the defined list:
    steps = re.split(r'\s*\,\s*', conf['steps'])
    # steps is something like ['eps', 'fea', 'otf', 'tex']
    log_lib.info(f"steps: {repr_identifiers_list(steps)}")

    tex_par = conf_to_tex_par(conf, font_basenames)
    renaming = rename_lib.main(conf)
    
    # write the renaming structure to a json file:
    with open(os.path.join(conf['json_dir'], 'renaming.json'), 'w') as fh:
        fh.write(json.dumps(renaming, indent=4, ensure_ascii=False))

    # 31.08.2019 16:49:50
    # tex_par is a list of (1- or 2-element) lists
    # write it in a readable way:
    s = repr_list_of_lists(tex_par)
    # ~ with open(conf['mp_to_tfm_par_file'] + '.new.json', 'w') as fh:
        # ~ fh.write(s)

    for fb in font_basenames:
        # overwrite fb in conf:
        conf['fb'] = fb
        log_lib.info(f"{'=' * 30} starting run for basename {fb}")

        # test/debug, 20.12.2019 11:46:24:
        json_font_fn = json_font_filename(conf)
        log_lib.debug(f"json font filename {json_font_fn}")

        one(conf, steps, tex_par, renaming, json_font_fn)
        log_lib.info(f"{'=' * 30} finished run for basename {fb}")
        log_lib.debug_separator(element='=')
        
    log_lib.info(f"{'-' * 30} Algotype run completed; log files closed")
    log_lib.debug_separator()
            
if __name__ == '__main__':
    main()