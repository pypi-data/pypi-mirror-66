#!/usr/bin/python3
# -*- coding: utf-8 -*-

# author: Marek Ryćko
__author__ = 'Marek Ryćko <marek@do.com.pl>'

'''
a library of functions
executing selected steps of transforming data

separated from the main running file
24.06.2019 15:48:30

1.
of generating eps files and an oti file
from a group of mp files

log file (generated by metapost)
fls file (report of inputs)
out file (if standard output goes to a file, not a screen)
are generated and put to a specified eps_log_dir directory

05.02.2019 05:11:50
start


2. generating fea file from oti file

translate the oti file
to a fea file

19.02.2019 17:16:23
start: coded in Python from bat file and bash script

3. generating fonts (oti and type1, the last containing pfb, afm, pfm files)

21.02.2019 03:51:37
attempts to eliminate python2 (not yet possible, due to fontforge restrictions)

'''

# standard library
import os
import subprocess   
import argparse
import sys
# extra imports for tfm generation:
import shutil
import json
import re


# modules of Algotype:
import algotype.config as config
import algotype.at_lib as lib
import algotype.run_lib as run_lib
import algotype.oti2fea3 as oti2fea3
import algotype.lm_fea as lm_fea
# extra imports for tfm generation:
import algotype.enc_map_lib as enc_map_lib
import algotype.json_font_lib as json_font_lib
import algotype.afm_lib as afm_lib
import algotype.pfb_lib as pfb_lib
# prints converted to log_lib function calls:
import algotype.log_lib as log_lib
# automatically generated file:
import algotype.make_algotype_ff as make_algotype_ff
# font and encodings renaming:
import algotype.rename_lib as rename_lib


# modules from MR library:
import algotype.time_lib as time_lib



def step_eps_oti(conf, rename=True):
    '''Make the step of generating eps files and possibly the oti file.
    
    conf is a parameter to this step
    (may contain more key-value entries than is needed)
    
    the generated eps files are (always) moved to the eps_dir directory
    and renamed, if the rename parameter is True
    '''

    fb = conf['fb']

    # intermediate directory; a place for eps files generated by metapost
    # (by the first of the steps below)
    # being also source files to another step — generating otf file
    eps_dir = conf['eps_dir']
    log_dir = conf['eps_log_dir']
    oti_dir = conf['oti_dir']

    lib.make_directory(eps_dir)
    lib.make_directory(log_dir)

    log_lib.info(f"{'-' * 30} running Metapost [{fb}]")
    run_lib.mp(conf, fb, run_lib.generating_eps)

    # save and change directory for the further actions:
    lib.dir_save()
    lib.dir_change(conf['mp_root_dir'])

    # move all eps files to the eps directory and rename them:
    lib.move_files('.', eps_dir, r'.*\.[0-9]+')
    
    if rename:
        lib.rename_eps(eps_dir)

    # append the reporting files to the debug log:
    def append_to_debug(path):
        '''
        append a text file path to the debug stream
        '''
        # read the string from the file:
        with open(path, 'r') as fh:
            s_log = fh.read()
        # ~ log_lib.debug_append(s_log)
        log_lib.debug(s_log)
    
    log_lib.debug(f"Metapost log for {fb}.mp:")
    append_to_debug(fb + '.log')
    
    # appending to log without printing to the screen (already done):
    # ~ log_lib.log_append(log_string)    
    
    # move some reporting files to the log directory:
    # move all log files (probably the only one) to the log directory
    lib.replace_file(fb + '.log', log_dir)
    # move the recorder fls file:
    lib.replace_file(fb + '.fls', log_dir)
    # move the stanard output, out, file:
    lib.replace_file(fb + '.out', log_dir)
    
    # some lm specific output or intermediate files are also moved
    # to the log directory:
    # move the dimensions, dim, file:
    lib.replace_file(fb + '.dim', log_dir)
    # move the kern, kpx, file:
    lib.replace_file(fb + '.kpx', log_dir)
    # move the font parameter info, pfi, file:
    lib.replace_file(fb + '.pfi', log_dir)
    # rename and move the piclist.tex file:
    lib.rename_file('piclist.tex', fb + '.piclist.tex')
    lib.replace_file(fb + '.piclist.tex', log_dir)

    # move the oti file to the oti directory (if the oti exists):
    if os.path.isfile(fb + '.oti'):
        lib.make_directory(oti_dir)
        lib.replace_file(fb + '.oti', oti_dir)

    # restore the current directory:
    lib.dir_restore()
    
def step_fea(conf):
    '''Make the step of generating a fea file (from an oti file).
    
    ...for the parameters in a dictionary conf
    '''

    # ------------------------------------------------------------------------------
    # config for oti to fea:

    # input oti file (generated by “mp_to_eps_oti” stage):
    oti_file = os.path.join(conf['oti_dir'], conf['fb'] + r'.oti')

    # input fea.dat file, hand prepared for this phase:
    inp_fea_file = conf['inp_fea_file']

    # output fea file; the result of this phase:
    out_fea_file = os.path.join(conf['fea_dir'], conf['fb'] + r'.fea')

    # create directory for the output fea file:
    lib.make_directory(conf['fea_dir'])

    # save and change directory:
    lib.dir_save()
    lib.dir_change(conf['mp_root_dir'])

    # run the python script
    # chagne it to a call of a fucnction

    # prepare the command line:
    # no more; now it is run as a library function
    # ~ cl = [python_3_engine, 'oti2fea3', oti_file, '-t', inp_fea_file, '-o', out_fea_file]

    # make the run, measuring time:
    time_lib.time_b()
    # ~ subprocess.run(cl)
    # generate the fea file only if the oti file exists:
    if os.path.isfile(oti_file):
        # 23.02.2019 18:01:56:
        oti2fea3.main(oti_file, inp_fea_file, out_fea_file, q=conf['oti_to_fea_quiet'])
    log_lib.debug(time_lib.time_e())

    # restore the directory
    lib.dir_restore()

def step_lm_fea(conf):
    '''Make the step of generating a fea file (from an oti file), LM-style.
    
    ...for the parameters in a dictionary conf
    '''

    # ------------------------------------------------------------------------------
    # config for oti to fea:

    # input oti file (generated by “mp_to_eps_oti” stage):
    oti_file = os.path.join(conf['oti_dir'], conf['fb'] + r'.oti')

    # input fea.dat file, hand prepared for this phase:
    inp_fea_file = conf['inp_fea_file']

    # output fea file; the result of this phase:
    out_fea_file = os.path.join(conf['fea_dir'], conf['fb'] + r'.fea')

    # possibly create directory for the output fea file:
    lib.make_directory(conf['fea_dir'])

    # save the current directory and change directory:
    lib.dir_save()
    lib.dir_change(conf['mp_root_dir'])

    # run the python script
    # chagne it to a call of a fucnction

    # prepare the command line:
    # no more; now it is run as a library function
    # ~ cl = [python_3_engine, 'oti2fea3', oti_file, '-t', inp_fea_file, '-o', out_fea_file]
    
    # the short font name, like 'lmr10', is in conf['fb']:

    # make the run, measuring time:
    time_lib.time_b()
    # ~ subprocess.run(cl)
    # generate the fea file only if the oti file exists:
    if os.path.isfile(oti_file):
        # 23.02.2019 18:01:56:
        lm_fea.main(oti_file, inp_fea_file, out_fea_file, conf['fb'], q=conf['oti_to_fea_quiet'])
    log_lib.debug(time_lib.time_e())

    # restore the directory
    lib.dir_restore()

def step_generate_json_font(conf):
    '''
    Generate a json font.
    
    for a given dictionary of parameters conf
    '''
    # ------------------------------------------------------------------------------
    # config for oti to font:

    # preparing and collecting data (paths) to this stage:

    # output font files; the result of this phase:
    # the output font directory path:
    otf_dir = conf['otf_dir']
    # the output files paths:
    pfb_file = os.path.join(conf['pfb_dir'], conf['fb'] + r'.pfb')
    otf_file = os.path.join(conf['otf_dir'], conf['fb'] + r'.otf')

    eps_dir = conf['eps_dir']
    log_dir = conf['eps_log_dir']
    oti_dir = conf['oti_dir']

    # input oti file (generated by “mp_to_eps_oti” stage):
    oti_file = os.path.join(conf['oti_dir'], conf['fb'] + r'.oti')

    # output fea file; the result of this phase:
    out_fea_file = os.path.join(conf['fea_dir'], conf['fb'] + r'.fea')


    lib.make_directory(conf['otf_dir'])
    lib.make_directory(conf['pfb_dir'])
    lib.make_directory(conf['oti_dir'])
    lib.make_directory(conf['temp_dir'])

    lib.make_directory(conf['pfb_dir'])
    lib.make_directory(conf['json_dir'])
    lib.make_directory(conf['temp_dir'])



    # --------------------------------------------------------------------------
    # generating json font:
    # --------------------------------------------------------------------------

    # engine for python 3:
    # ~ engine = 'python3'
    # ~ script_basename = 'json_font'
    # 21.02.2019 03:51:37:
    # ~ engine = 'python3'; script_basename = 'ffdkm3'

    # python (2) script realizing the translation from the oti file and fea.dat file
    # to the fea file:
    # the script is to be located in some path visible for python
    # ~ python_dir = os.getcwd()
    # ~ script = os.path.join(python_dir, script_basename + '.py')
    # 21.02.2019 03:58:41:
    # ~ script = os.path.join(python_dir, 'ffdkm3.py')

    lib.dir_save()
    # ~ lib.dir_change(conf['font_gen_root'])
    lib.dir_change(conf['mp_root_dir'])

    log_lib.info("Reading OTI file <", oti_file)

    # prepare a structural parameter to the make_json call:

    par = {
        'iname': oti_file,

        # temporarily, 22.01.2019 13:41:10, before making it an argument:
        # input EPS directory:
        # 19.02.2019 23:57:45:
        'edir': eps_dir,
        'jgname': os.path.join(conf['json_dir'], conf['fb'] + '_goadb.json'),
        'jglname': os.path.join(conf['json_dir'], conf['fb'] + '_glyph.json'),
        'joname': os.path.join(conf['json_dir'], conf['fb'] + '_oti.json'),
        'jfname': os.path.join(conf['json_dir'], conf['fb'] + '_font.json'),

        'otiname': oti_file,

        'fename': [out_fea_file],
        'gname': conf['goadb_file'],

        # quiet is not respected yet
        'quiet': False,
        'pydir': eps_dir,

    }

    # make the run, measuring time:
    time_lib.time_b()
    
    # no subprocess any more; just a function call:
    json_font_lib.one_json_font(par)
    
    # stop measuring time:
    log_lib.debug(time_lib.time_e())

    lib.dir_restore()


def step_generate_fonts_otf_pfb(conf, json_font):
    '''
    generate fonts (otf and pfb)
    
    for a given dictionary of parameters conf
    '''
    # ------------------------------------------------------------------------------
    # config for oti to font:

    # preparing and collecting data (paths) to this stage:

    # output font files; the result of this phase:
    # the output font directory path:
    otf_dir = conf['otf_dir']
    # the output files paths:
    pfb_file = os.path.join(conf['pfb_dir'], conf['fb'] + r'.pfb')
    otf_file = os.path.join(conf['otf_dir'], conf['fb'] + r'.otf')
    sfd_file = os.path.join(conf['otf_dir'], conf['fb'] + r'.sfd')

    eps_dir = conf['eps_dir']
    log_dir = conf['eps_log_dir']
    oti_dir = conf['oti_dir']

    # input oti file (generated by “mp_to_eps_oti” stage):
    oti_file = os.path.join(conf['oti_dir'], conf['fb'] + r'.oti')

    # output fea file; the result of this phase:
    out_fea_file = os.path.join(conf['fea_dir'], conf['fb'] + r'.fea')


    lib.make_directory(conf['otf_dir'])
    lib.make_directory(conf['pfb_dir'])
    lib.make_directory(conf['oti_dir'])
    lib.make_directory(conf['temp_dir'])

    lib.make_directory(conf['pfb_dir'])
    lib.make_directory(conf['json_dir'])
    lib.make_directory(conf['temp_dir'])




    # --------------------------------------------------------------------------
    # from json font to traditional font:
    # --------------------------------------------------------------------------

    # python for Fontforte (python_ff) script to run:

    # engine for python 2
    try:
        # new name, as of 24.03.2020:
        engine = conf['python_for_ff']
    except:
        try:
            engine = conf['python2']
        except:
            log_lib.critical('Python for Fontforge engine (python_for_ff or python2 entry) not defined in config.')
            
    # we have a Python for Fontforge engine defined
    
    # --------------------------------------------------------------------------
    # try to run the engine for a moment to get its version
    
    cl = [engine, '--version']

    # ~ standard_output_path = os.path.join(conf['otf_dir'], conf['fb'] + r'.out')
    # ~ standard_output_handle = open(standard_output_path, 'w')
    # ~ standard_error_handle = standard_output_handle
    
    # ~ proc = subprocess.Popen('ls', stdout=subprocess.PIPE)
    # ~ output = proc.stdout.read()
    engine_version_bytes = subprocess.check_output(cl, stderr=subprocess.STDOUT, \
        shell=False)

    engine_version_str = engine_version_bytes.decode('ascii').strip()
    debug_info = f"engine version [{engine_version_str}]"
    log_lib.debug(debug_info)
    
    # read version elements from the version string:
    pattern = r'Python ([0-9]+)\.([0-9]+)\.([0-9]+)'
    mo = re.search(pattern, engine_version_str)
    if mo:
        # the string has a correct construction
        major = int(mo.group(1))
        minor = int(mo.group(2))
        micro = int(mo.group(3))
        info_str = f"Recognized Python version {major}.{minor}.{micro} for running Fontforge"
        log_lib.info(info_str)
    else:
        # the python version not recognized in the test output string
        debug_str = f"Python version not recognized in the output of '{engine} --version'"
        log_lib.critical(debug_str)
    
    # --------------------------------------------------------------------------
    # write a script calling either some Python 2 or Python 3
    # to a temporary (or maybe current) directory
    
    # prepare a python2 calling structure:
    # we prepare the Python 2 running dir in the temp area:
    area = conf['temp_dir']
    make_algotype_ff.create_structure(area, major, minor, micro)
    
    script_basename = 'ff_make_font_run.py'
    script_run_dir = 'ff_make_font_run_dir'
    script_path = os.path.join(area, script_run_dir, script_basename)


    # ~ script_basename = 'ffdkm'
    # 17.03.2020 17:18:29:
    # ~ script_basename = 'ff_make_font'
    # ~ script_basename = 'ff_make_font_run'

    # python (2) script realizing the translation from the oti file and fea.dat file
    # to the fea file:
    # the script is to be located in some path visible for python
    python_dir = os.getcwd()
    # ~ script = os.path.join(python_dir, script_basename + '.py')
    # ~ script = os.path.join(python_dir, script_basename)
    # ~ script = script_basename + '.py'
    # ~ script = script_basename

    # ~ log_lib.info(f"writing temporary file calling a fonforge package:")
    # ~ log_lib.info(f"{script}")
    # ~ with open(script, 'w') as fh:
        # ~ fh.write(ff_make_font_string)

    lib.dir_save()
    # ~ lib.dir_change(conf['font_gen_root'])
    lib.dir_change(conf['mp_root_dir'])

    json_font_path = os.path.join(conf['json_dir'], conf['fb'] + '_font.json')

    # ~ standard_output_path = os.path.join(conf['otf_dir'], conf['fb'] + r'.out')
    # ~ standard_output_handle = open(standard_output_path, 'w')
    # ~ standard_error_handle = standard_output_handle

    # python ../ffdkm.py $srcdir/$FNAME.oti  -ah -v -s -t $resdir/$FNAME.pfb  -f $resdir/$FNAME.fea -g ../goadbff.txt -aa -o $resdir/$FNAME.otf -s -x use_typo_metrics#1 
    #   -ah -v -s -t $resdir/$FNAME.pfb  -f $resdir/$FNAME.fea -g ../goadbff.txt -aa -o $resdir/$FNAME.otf -s -x use_typo_metrics#1 
    cl = [
        # ~ '-m',
        # ~ engine, script,
        engine, script_path,
        # ~ script,
        # input oti file
        oti_file,
        '-oti', oti_file,
        '-te', conf['temp_dir'],
        '-p', python_dir,
        '-e', eps_dir,
        '-jo', os.path.join(conf['json_dir'], conf['fb'] + '_oti.json'),
        '-jg', os.path.join(conf['json_dir'], conf['fb'] + '_goadb.json'),
        '-jf', json_font_path,
        '-ah',
        # no more validate font special warning file, as of 20.04.2020 23:08:30:
        # '-v',
        '-s',
        '-t', pfb_file,
        '-f', out_fea_file,
        '-g', conf['goadb_file'],
        '-aa',
        '-o', otf_file,
        '-s', sfd_file,
        '-x', r'use_typo_metrics#1']

    # ~ log_lib.debug('\n'.join(cl))
    # ~ log_lib.info('\n'.join(cl))

    log_lib.debug_separator(element='.')
    log_lib.info(f"{'.' * 30} subprocess {conf['fb']}:")

    # make the run, measuring time:
    time_lib.time_b()
    try:
        subprocess.run(cl)
        # 01.04.2019 13:27:59:
        # ~ subprocess.run(cl, stdout=standard_output_handle, stderr=standard_error_handle)
        pass
    except:
        log_lib.critical('problem running script:' + ' '.join(cl))

    log_lib.debug(time_lib.time_e())
    
    # collect the log and debug files from the subprocess just finished
    # and append it to the main log and debug files:
    
    log_name = os.path.join(conf['temp_dir'], 'algotype_font_generation_log.txt')
    debug_name = os.path.join(conf['temp_dir'], 'algotype_font_generation_debug.txt')
    
    # read the files to strings:
    
    try:
        with open(log_name, 'r') as fh:
            log_string = fh.read()
    except:
        log_lib.error(f"cannot read Fontforge log file {log_name}")
        log_string = ''

    try:
        with open(debug_name, 'r') as fh:
            debug_string = fh.read()
    except:
        log_lib.error(f"cannot read Fontforge debug file {debug_name}")
        debug_string = ''
        
    # log_string and debug_string defined;
    # append them to the main log and debug files:
    
    log_lib.debug_append(debug_string)
    # appending to log without printing to the screen (already done):
    log_lib.log_append(log_string)
    
    # --------------------------------------------------------------------------
    # font hopefully generated
    
    # rename the otf file if the renaming definition file in config:
    
    if 'otf_renaming_file' in conf:
        fn = conf['otf_renaming_file']
        
        # read otf renaming file and parse it to a dictionary
        with open(fn, 'r') as fh:
            otf_renaming_string = fh.read()
        otf_renaming_dict = rename_lib.otf_rename_str_to_dict(otf_renaming_string)
        log_lib.debug(f"otf_renaming_dict defined; len = {len(otf_renaming_dict)}")
        
        # rename the otf and sfd files:
        os.path.splitext(otf_file)
        dirname, filename = os.path.split(otf_file)
        base, ext = os.path.splitext(filename)
        # ext is '.otf' or '.sfd'
        
        # find a new filename after renaming:
        if base in otf_renaming_dict:
            # ok, prepare the new basename:
            new_base = otf_renaming_dict[base]
            log_lib.info(f"renaming otf and sfd: {base} --> {new_base}")
        else:
            log_lib.warning(f"entry for renaming {base} not found")
            new_base = base
            
        
        new_otf_file = os.path.join(dirname, new_base + '.otf')
        new_sfd_file = os.path.join(dirname, new_base + '.sfd')
        
        os.rename(otf_file, new_otf_file)
        os.rename(sfd_file, new_sfd_file)
        
        # ~ log_lib.info(f"renaming otf and sfd: {otf_file} --> {new_otf_file}")
        
    
    # --------------------------------------------------------------------------
    
    
    if 1:
        # generate afm file without FontForge, using Algotype library:
        
        # 1.
        # read a font_json string and put it into a structure:
        with open(json_font_path, 'r') as fh:
            json_string = fh.read()
        json_font = json.loads(json_string)
        
        # 2.
        # generate afm structure and string:
        afm_json = afm_lib.json_font_to_json_afm(json_font)
        afm_string = afm_lib.afm_json_to_string(afm_json)
        
        # 3.
        # prepare the names of afm files in concern:
        # the main name of afm file is generated from pfb file name (change it):
        # ~ afm_filename = pfb_file.replace('.pfb', '.afm')
        afm_basename = pfb_file.replace('.pfb', '')
        afm_filename = afm_basename + '.afm'
        # algotype generated name:
        afm_filename_at = afm_basename + '_at.afm'
        # fontforge generated name:
        afm_filename_ff = afm_basename + '_ff.afm'

        # 3a.
        # now we know the afm name; writing to the logs:
        log_lib.info(f"generating AFM file: {afm_filename}")

        # 4.
        # rename the existing afm file, generated by fontforge
        # and write the newly generated afm:
        # (a) change the name of the existing file (if exists):
        lib.move_file(afm_filename, afm_filename_ff)
        if 0:
            # another possible version of moving/renaming:
            try:
                os.rename(afm_filename, afm_filename_ff)
            except:
                # no problem, if renaming is not possible
                pass
        # (b) write the afm_string both to final .afm and to _at.afm:
        # overwrite the existing files
        if os.path.exists(afm_filename):
            os.remove(afm_filename)
        with open(afm_filename, 'w') as fh:
            fh.write(afm_string)
        if os.path.exists(afm_filename_at):
            os.remove(afm_filename_at)
        with open(afm_filename_at, 'w') as fh:
            fh.write(afm_string)

    if 1:
        # correct a pfb file generated by FontForge
        
        
        # disassemble/assemble engines:
        t1asm_engine = conf['t1asm_engine']
        t1disasm_engine = conf['t1disasm_engine']
        
        # filenames to be used:
        pfb_basename = pfb_file.replace('.pfb', '')
        
        # pfb, assembled, filenames:
        pfb_filename = pfb_basename + '.pfb'
        # algotype generated name:
        pfb_filename_at = pfb_basename + '_at.pfb'
        # fontforge generated name:
        pfb_filename_ff = pfb_basename + '_ff.pfb'

        # pfd, disassembled, filenames:
        pfd_filename = pfb_basename + '.pfd'
        # algotype generated name:
        pfd_filename_at = pfb_basename + '_at.pfd'
        # fontforge generated name:
        pfd_filename_ff = pfb_basename + '_ff.pfd'
        
        # 3a.
        # now we know the pfb name; writing to the logs:
        log_lib.info(f"correcting PFB file generated by Fontforge: {pfb_filename}")

        
        # disassemble the pfb file generated by FontForge
        # saving the temporal result in a tmp directory
        
        # ~ temp_dir = conf['temp_dir']
        cl = [t1disasm_engine, pfb_filename]
        if os.path.exists(pfd_filename_ff):
            os.remove(pfd_filename_ff)
        with open(pfd_filename_ff, 'w') as standard_output_handle:
            try:
                #subprocess.run(cl)
                # 21.01.2020 18:14:49:
                subprocess.run(cl, stdout=standard_output_handle)
                # 01.04.2019 13:27:59:
                # ~ subprocess.run(cl, stdout=standard_output_handle, stderr=standard_error_handle)
                pass
            except:
                log_lib.critical('problem running program:' + ' '.join(cl))
        # probably pfd_filename_ff is generated
        # read it as a string:
        with open(pfd_filename_ff, 'r') as fh:
            pfd_string = fh.read()
        # we have an original, disassembled string
        # convert it on the base of json_font
        pfd_string_new = pfb_lib.pfd_convert(pfd_string, json_font)
        # we have a converted pfd string
        with open(pfd_filename_at, 'w') as fh:
            fh.write(pfd_string_new)
        # algotype generated pfd string is ready
        # assemble it back to the pfb file
        cl = [t1asm_engine, pfd_filename_at]
        with open(pfb_filename_at, 'wb') as standard_output_handle:
            try:
                #subprocess.run(cl)
                # 21.01.2020 18:14:49:
                subprocess.run(cl, stdout=standard_output_handle)
                pass
            except:
                log_lib.critical('problem running program:' + ' '.join(cl))
        # algotype pfb probably written
        # let’s make some renaming and copying:
        # move the original pfb:
        lib.move_file(pfb_filename, pfb_filename_ff)
        # copy the generated pfb to the original name:
        lib.copy_file(pfb_filename_at, pfb_filename)
        # probably all the pfb and pfd files are created and namet correctly
        
        # the end of generation/correction of pfb
        
        

    lib.dir_restore()

# ------------------------------------------------------------------------------
# processing metapost input to generate a single tfm:
# ------------------------------------------------------------------------------

def step_tex_one(conf, p, renaming, json_font):
    '''
    For some data from the conf and for p, described below, generate
    tfm, enc, map and some other files.
    
    parameters:
    
    p is of the form:
        p = [enc]
    or:
        p = [enc, sc]
    
    where:
    
    :: enc -- name of encoding (suffix of the respective Metapost encoding file),
              eg. cs, ec, l7x, q
    :: sc  -- empty or, for small caps, sc 
    
    fb  -- font name (without extesion), eg. gagr, qagb
        comes from conf['fb']
    
    the current directory of conf['mp_root_dir'] is assumed
    
    if renaming is not None, it is a json strucutre
    (a dictionary of three structures, in fact)
    defining the naming and renamig of files and some internal names
    from: tfm, enc, internal enc, metapost enc
    
    '''
    if renaming is not None:
        # prepare the renaming structures:
        otf_renaming = renaming['otf']
        pfb_renaming = renaming['pfb']
        enc_mp_relation = renaming['enc_mp']
    
    
    # the bare filename, like “qagri” comes from the config
    # this is a bare name of the font, including
    #   its 'gen_name', like 'lm' or 'qag'
    # and
    #   its style name, like 'r10' or 'r'
    fb = conf['fb']
    
    # the encoding parameters come from p:
    if len(p) == 1:
        enc = p[0]
        sc = ''
    elif len(p) == 2:
        enc, sc = p
    else:
        # this should not happen
        log_lib.critical('wrong parameter structure in the step of tfm generation')
        
    # this is good time to tell, what we are doing:
    par_repr = f"encoding {repr(enc)}" + (f" with small caps" if sc else '')
    log_lib.info(f"step tex for {conf['fb']}: {par_repr}")
    
    # local config:
    do_mp = True
    # ~ do_mp = False
    do_py = True
    # ~ do_py = False
    
    # exception (timeworn tradition):
    if enc == 'yy':
        # for the input metapost encoding file containing 'yy'
        # use in all output files another string:
        tfm_kernel = 'texnansi'
    else:
        tfm_kernel = enc

    pfb_name = fb + '.pfb'

    # :: initially no tfm extension:
    # :: TFM and OTI share the same name, that's why extension is not appended

    joiner = '-'
    # enc_prefix = 'q'
    # now this is general, read from the config file:
    enc_prefix = conf['enc_prefix']
    
    # “base” is the filename without extension (and without ext separator)
    if sc == '':
        tfm_base = joiner.join([tfm_kernel, fb])
        enc_base = joiner.join([enc_prefix, tfm_kernel])
        
    else:
        tfm_base = joiner.join([tfm_kernel, fb, sc])
        enc_base = joiner.join([enc_prefix, tfm_kernel, sc])
        
    enc_name = enc_base + '.enc'
    tfm_name = tfm_base + '.tfm'

    # run config:
   
    lib.make_directory(conf['tfm_dir'])
    lib.make_directory(conf['tfm_log_dir'])
    lib.make_directory(conf['tfm_oti_dir'])
    lib.make_directory(conf['map_dir'])
    lib.make_directory(conf['enc_dir'])

    tfm_dir = conf['tfm_dir']
    
    # calculate the mono / not mono element:

    if 0:
        # used to be:
        is_mono = conf['gen_name'] == 'qcr'
    else:
        # general way, from 22.04.2020 15:18:13:
        fixed_pitch = json_font['oti_par']['FIXED_PITCH']
        is_mono = fixed_pitch.lower() == 'true'
        log_lib.debug(f"fixed_pitch from oti = {fixed_pitch}, is_mono = {is_mono}")
    
    sx_mono = 'tt' if is_mono else ''

    # basename of metapost encoding file:
    enc_mp_base = joiner.join(['e', enc + sx_mono + sc])


    # --------------------------------------------------------------------------
    # --------------------------------------------------------------------------

    # clean up before we start:
    # why is this?
    # ~ lib.file_remove('lm-tex.mpe')

    
    
    # --------------------------------------------------------------------------
    # mp part:
    # --------------------------------------------------------------------------
    if do_mp:
        
        # copy one of the e-something.mp files (encoding metapost files)
        # to lm-tex.mpe
        # in a bat file it looked like this:
        # copy %METATYPE1%\e-%2%_SX_MONO%%3.mp lm-tex.mpe
        enc_mp_dir = conf['enc_mp_dir']
        
        # now we have in hands both:
        #   enc_mp_base
        # and:
        #   enc_base
        # they both exist in enc_mp part of renaming structure;
        # make sure the calculations are correct:
        
        if renaming['enc_mp'][enc_base] == enc_mp_base:
            # everything is OK
            m = f"enc_base = {repr(enc_base)} and " + \
                f"enc_mp_base = {repr(enc_mp_base)} are consistent"
            log_lib.debug(m)
        else:
            # everything is OK
            m = f"enc_base = {repr(enc_base)} and " + \
                f"enc_mp_base = {repr(enc_mp_base)} are NOT consistent " + \
                f"wrt renaming['enc_mp']"
            log_lib.error(m)
            
        # the variables:
        #   enc_mp_base
        # and:
        #   enc_base
        # are either correct or the inconsistency has been announced
                
        enc_mp_fn = enc_mp_base + '.mp'
        enc_mp_path = os.path.join(enc_mp_dir, enc_mp_fn)
        mpe_file = os.path.join(conf['mp_root_dir'], 'lm-tex.mpe')
        lib.copy_file(enc_mp_path, mpe_file)

        # save and change directory for the further actions:
        lib.dir_save()
        lib.dir_change(conf['mp_root_dir'])


        
        # mp \generating:=1; \input <fb>.mp
        log_lib.info(f"running {conf['metapost_engine']} \\generating:=1; \\input {fb}.mp")
        run_lib.mp(conf, fb, run_lib.generating_tfm)

        # ~ if "%1"=="%_TFMNAME%" goto SHOULDNTHAPPEN
        
        
        # metapost suposedly generated files: tfm, log, oti, ps
        # renaming and moving files:

        # ~ ren %1.tfm %_TFMNAME%.tfm
        # ~ ren %1.log %_TFMNAME%.lo
        # ~ ren %1.oti %_TFMNAME%.oti
        # ~ xcopy /Y %_TFMNAME%.* %_RESDIR%\*.*
        
        # let know to the debug file what files has been generated:
        
        log_lib.debug(f"the tfm_base = {tfm_base}")
        
        # preparing renaming according to the data from
        # the renaming_lib module; the renaming structure
        # for the known three basic parameters:
        #   1. tfm_base name (tfm_kernel (= enc possibly modified) + fb)
        #   2. enc
        #   3. sc (= 'sc' or '') meaning if it is small caps
        
        # the directories are already created:
        
        # rename and move tfm file:
        lib.rename_file(fb + '.tfm', tfm_base + '.tfm')
        lib.replace_file(tfm_base + '.tfm', tfm_dir)
        
        # rename and move log file:
        lib.rename_file(fb + '.log', tfm_base + '.log')
        lib.replace_file(tfm_base + '.log', conf['tfm_log_dir'])

        # rename and move recorder fls file:
        lib.rename_file(fb + '.fls', tfm_base + '.fls')
        lib.replace_file(tfm_base + '.fls', conf['tfm_log_dir'])

        # rename and move out file:
        lib.rename_file(fb + '.out', tfm_base + '.out')
        lib.replace_file(tfm_base + '.out', conf['tfm_log_dir'])

        # rename and move oti file:
        lib.rename_file(fb + '.oti', tfm_base + '.oti')
        lib.replace_file(tfm_base + '.oti', conf['tfm_oti_dir'])

        # possibly remove some more
        # ~ if exist %_TFMNAME%.* del %_TFMNAME%.*
        # we could use here:
        # ~ def purge(dir, pattern):
            # ~ for f in os.listdir(dir):
                # ~ if re.search(pattern, f):
                    # ~ os.remove(os.path.join(dir, f))
        # but it would be inefficient
        
        # the generated ps file is (empty and) useless:
        # ~ if exist %1.ps del %1.ps
        lib.file_remove(fb + '.ps')
        
        # the mpe file is not needed any more; a new one will be generated
        lib.file_remove(mpe_file)

        # restore the current directory:
        lib.dir_restore()





    # --------------------------------------------------------------------------
    # py part:
    # --------------------------------------------------------------------------
    if do_py:

        # save and change directory for the further actions:
        # ~ cd %_RESDIR%
        lib.dir_save()
        lib.dir_change(tfm_dir)

        # ~ :: python ../../oti2enc.py -v -c TG -e %_ENCNAME% -m %_MAPNAME% -t %_TFMNAME%.tfm -p %_PFBNAME%.pfb %_TFMNAME%.oti
        # ~ :: TFM names are used only for creating MAP files, hence extesion is superfluous:
        # in the original BAT file the extension .pfb was added to the file name twice
        # ~ python ../../oti2enc.py -v -c TG -e %_ENCNAME% -m %_MAPNAME% -t %_TFMNAME% -p %_PFBNAME%.pfb %_TFMNAME%.oti
        
        # collect parameters to the oti2enc main function call
        
        
        map_name = os.path.join(conf['map_dir'], conf['gen_name'] + '.map')

        
        # prepare the values of encoding name and internal encoding name
        # from the renaming structure:
        
        encoding_base_r = renaming['pfb'][fb][tfm_base][0]
        m = f"encoding name from renaming structure for fb = {fb} " + \
            f"tfm_base = {tfm_base} is {encoding_base_r}"
        log_lib.debug(m)
        # internal encoding name:
        encoding_int_name_r = renaming['pfb'][fb][tfm_base][1]
        m = f"internal encoding name from renaming structure for fb = {fb} " + \
            f"tfm_base = {tfm_base} is {encoding_int_name_r}"
        log_lib.debug(m)
        
        # check if the previously calculated and coming from the renaming structure
        # values of encoding name are equal:
        if enc_base == encoding_base_r:
            # everything is OK
            m = f"enc_base = {repr(enc_base)} and " + \
                f"enc_base from renaming structure = {repr(encoding_base_r)} are equal"
            log_lib.debug(m)
        else:
            # everything is OK
            m = f"enc_base = {repr(enc_base)} and " + \
                f"enc_base from renaming structure = {repr(encoding_base_r)} are NOT equal"
            log_lib.error(m)

        # enc_name is just enc_base plus '.enc'
        
        
        
        par = {
            # verbose True — info goes to a default file name:
            # (may be True, False or the output filename)
            # not used any more, as of 22.04.2020 20:20:07:
            # ~ 'verbose': True,
            # the input oti filename (may be relative to the tfm_dir):
            # not used any more, as of 22.04.2020 20:30:59:
            # 'oti': tfm_base + '.oti',
            # the input json_font structure (including OTI):
            'json_font': json_font,
            # the input pfb filename (may be relative to the tfm_dir):
            'pfb': pfb_name,
            # the input tfm filename (without extensions)
            # relative to the tfm_dir:
            'tfm': tfm_base,
            # output:
            # the output enc filename:
            'enc': enc_name,
            # the output internal enc name
            'enc_int': encoding_int_name_r,
            # the output map filename:
            'map': map_name,
            # False or a string denoting an identifier of a set of comment templates
            # the string may be something like 'TG'
            'comments': conf['family_name_id'] if 'family_name_id' in conf else False,
        }       
        
        # ~ log_lib.debug(par['oti'])
         
        enc_map_lib.main(conf, par)
       
        # restore the current directory:
        lib.dir_restore()
       
        # in a bat file it looked like this:
        # ~ cd ..
        # ~ :: echo %METATYPE1% %_CURRMP% %_RESDIR% ::: python ... -e %_ENCNAME% -m %_MAPNAME% -t %_TFMNAME%.tfm -p %_PFBNAME%.pfb %_TFMNAME%.oti

def step_tex(conf, par, renaming, json_font):
    '''
    run a series of step_tex_one functions
    generating tfm, enc and map files
    
    use par as a list of run parameters (strings being font basenames)
    
    if renaming is not None, it is a json strucutre
    (a dictionary of three structures, in fact)
    defining the naming and renamig of files and some internal names
    from: tfm, enc, internal enc, metapost enc
    '''
    # ------------------------------------------------------------------------------
    # prepare all the output directories:
    # ------------------------------------------------------------------------------
    lib.make_directory(conf['json_dir'])

    # make the run, measuring time:
    time_lib.time_b()

    for p in par:
        
        step_tex_one(conf, p, renaming, json_font)
        
    log_lib.debug(time_lib.time_e())

