#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''
parse_eps.py
a parser of EPS files (strings)
as generated by Metapost in the Algotype system

Marek RyÄ‡ko

start as a copy of parse_goadb
cut out from ffdklib (ffdklib3)
12.09.2019 20:43:45
'''

# probably re is sufficient:
# ~ import regex as re
import re

# Algotype:
import algotype.log_lib as log_lib
    
def wrap(s):
    return '[%s]' % s


def parse_eps(s):
    '''
    parse an EPS string and return a structure
    '''
    # split the input string to a list of lines:
    # sl -- string list
    sl = s.splitlines()
    
    # create the line list with line numbers (indexes plus one):
    ll = []
    for i, l in enumerate(sl):
        l = l.rstrip() # remove DOS/UNIX EOLs
        # ~ ll.append([i + 1, l])
        # put index, line number and the line to the structure
        ll.append({'i': i, 'n': i + 1, 'l': l})

    # ~ log_lib.debug(repr_lines(ll))
    
    # split the list of lines to the three parts:
    # 1. metainformation
    # 2. body
    # 3. ending
    # retaining the line numbers
    
    meta = []
    body = []
    ending = []
    was_body = False
    
    # lines starting from ## or #! at the beginning are metainformation
    # then there is body, not starting from those strings
    # then there is an ending
    
    for ls in ll:
        # ls is a line structure within all the ll, the current parsing state
        if ls['l'].startswith('%%') or ls['l'].startswith('%!'):
            if was_body:
                ending.append(ls)
            else:
                meta.append(ls)
        else:
            body.append(ls)
            was_body = True
    
    # filter out empty, whitespace and comment lines:
    pat = '^\s*(\#.*)?$'
    patc = re.compile(pat)
    def regular(line):
        mo = patc.match(line)
        if mo:
            res = False
            # ~ print line
        else:
            res = True 
        return res
            
    # ~ sl = list(filter(regular, sl))

    # ~ log_lib.debug('meta')
    # ~ log_lib.debug(repr_lines(meta))
    # ~ log_lib.debug('body')
    # ~ log_lib.debug(repr_lines(body))
    # ~ log_lib.debug('ending')
    # ~ log_lib.debug(repr_lines(ending))
    
    m = parse_meta(meta)
    b = parse_body(body)    
    # the ending part of eps is silently skipped
    
    res = {'meta': m, 'body': b}
    return res

def parse_meta(ll):
    '''
    parse a metainformation part of the eps
    
    The metainformation part is of the form:
    %!PS
    %%BoundingBox: 0 0 800 800.
    %%HiResBoundingBox: 0 0 800 800.
    %%Creator: MetaPost 2.00
    %%CreationDate: 2019.09.09:0042
    %%Pages: 1
    %%BeginProlog
    %%EndProlog
    %%Page: 1 1
    '''
    # no information is returned yet
    # in fact for the purpose of Algotype
    # most of the information is not important
    res = {}
    # split each line to a sequence of units/command
    # (in this type of eps there are no commands exceding one line)
    
    ok = True
    for ls in ll:
        for ge in meta_grammar:
        # ~ for ge in meta_grammar[0:1]:
            # ge is a grammar element
            # ~ log_lib.debug(ge)
            found = False
            
            # ~ if ge['command'] == 'Creator':
            if 0:
                # use a different grammar:
                pattern = r'\%\%(Creator):\s+(\S.*)$'
                compiled = re.compile(pattern)
            else:
                compiled = ge['compiled']
                
            # calculate the match object mo:
            mo = compiled.match(ls['l'])
            if mo:
                # yes, we found the pattern:
                found = True
                # finish the (inner) loop
                # ~ log_lib.debug(mo.group(1))
                # ~ log_lib.debug('found %-20s vs %s' % (ge['command'], ls['l']), str(found))
                
                # create an information value:
                if ge['n'] == 'rest':
                    # the string value:
                    v = [mo.group(2)]
                else:
                    # a list of integers or floats
                    try:
                        v = [int(s) for s in mo.groups()[1:]]
                        # ~ v = mo.groups()[1:]
                    except:
                        try:
                            v = [float(s) for s in mo.groups()[1:]]
                        except:
                            v = ['at least one not number value']
                # ~ log_lib.debug('found %-20s vs %s' % (ge['command'], ls['l']), str(v))
                res[ge['command']] = v
                break

    # ~ res = {'ok': ok, 'us': us}
    return res


def parse_body(ll):
    '''
    parse the body part of the eps
    
    The body part is:
    a sequence of commands with structural parameters
    '''
    # split each line to a sequence of units/command
    # (in this type of eps there are no commands exceding one line)
    
    us = []
    ok = True
    for ls in ll:
        r = string_to_units(ls)
        if r['ok']:
            # res = {'ok': ok, 'us': us}
            us.extend(r['us'])
        else:
            ok = False
            break
    res = {'ok': ok, 'us': us}
    return res

def string_to_units(ls):
    '''
    read a line structure of the form at least:
    {'n': line number, ... 'l': line string}
    where l is a single-line string
    
    and translate it into the sequence of units/commands of the form:
        {
        't': type, that is, the command name,
        'a': possibly empty dictionary of attributes,
        'v': a structural value; a (possibly empty) list of command parameters
        }
    we will put localization information (line number and column number)
    to the attribute dictionary
    '''
    
    l = ls['l']
    pos = 0
    # the ok value will remain True, unless it is falsified in some point:
    ok = True
    
    # collect the resulting unit sequence:
    us = []

    while pos < len(l):
        # there is a nonempty string to analyse:
        p = {'pos': pos, 's': l}
        r = parse_one(p)
        if r['ok']:
            # some pattern found:

            ge = r['ge']
            mo = r['mo']
            # ~ log_lib.debug('%5s %10s' % (str(r['ok']), ge['command']), wrap(mo.group(0)))

            # construct a resulting unit:

            v = []
            for i in range(ge['n']):
                v.append(int(mo.group(i + 1)))
            # ~ log_lib.debug(v)

            a = {'n': ls['n'], 'pos': mo.span()[0]}


            u = {'t': ge['command'], 'a': a, 'v': v}
            # ~ log_lib.debug(u)
            us.append(u)
            
            pos = mo.span()[1]
        else:
            
            log_lib.error('cannot compile line %d at position %d' % (ls['n'], pos))
            ok = False
            break

    res = {'ok': ok, 'us': us}
    return res

def parse_one(p):
    '''
    parse a single unit at the beginning of string
    using a global object grammar
    
    p is a parameter dictionary:
    p = {
        pos: starting position within the string
        s: the string to be parsed
    }
    
    return a parsing result:
    
    res = {
        ok: True
        pos: position after this recognizing
        t: type of command, that is, the command name
        v: parameters to the command
    }
    
    or:
    
    res = {
        ok: False
        # ~ m: message
    }
    
    '''
    global grammar
    
    s = p['s']
    pos = p['pos']
    
    ok = False
    for ge in grammar:
        # ge is a grammar element
        # calculate the match object mo:
        mo = ge['compiled'].match(s, pos)
        if mo:
            # yes, we found the pattern:
            ok = True
            # finish the loop
            break
    # ok set and for ok == True: ge and mo set
    if ok:
        res = {'ok': True, 'ge': ge, 'mo': mo}
    else:
        res = {'ok': False}
    return res

# grammar data contains information about each eps command
# and number of numerical parameters
grammar_data = [
    ['setrgbcolor', 3],
    # added:
    ['setgray', 1],
    ['newpath', 0],
    ['moveto', 2],
    ['lineto', 2],
    ['curveto', 6],
    # lineto was erroneously repeated; removed 02.01.2020 15:06:59:
    # ~ ['lineto', 2],
    ['closepath', 0],
    ['fill', 0],
    ['showpage', 0],
]

# meta grammar data contains information about meta data
# and number of string parameters
meta_grammar_data = [
    ['BoundingBox', 4],
    ['HiResBoundingBox', 4],
    ['Creator', 'rest'],
    ['CreationDate', 'rest'],
    ['Pages', 1],
    # those two are not bearing any information:
    ['BeginProlog', 0],
    ['EndProlog', 0],
    ['Page', 2],
]

def make_meta_grammar(gd):
    '''
    take a meta grammar data and make the grammar
    as it is used in line parsing function in the meta section
    '''
    g = []
    for f, x in gd:
        # prepare the regular expression for the object f, x
        # ~ log_lib.debug('making grammar structure for %s, %s' % (f, str(x)))
        if isinstance(x, str) and x == 'rest':
            # use a different grammar:
            pattern = r'\%%\%%(%s):\s+(\S.*)$' % f
            compiled = re.compile(pattern)
        elif isinstance(x, int):
            # double percent sign at the beginning:
            pattern = r'\%\%'
            # the command/key name at the beginning:
            pattern += r'(%s)' % f
            # a colon for more then one parameter:
            if isinstance(x, str) or x > 0:
                pattern += r':\s+'

            # x times a non-space sequence joined/separated by at least one space:
            pattern += r'\s+'.join([r'(\S+)' for i in range(x)])
            # the whole line must match the pattern:
            pattern += r'$'
            # compile the pattern:
            compiled = re.compile(pattern)

        # in the resulting grammar we retain the command and number of parameters:
        g.append({'command': f, 'n': x, 'pattern': pattern, 'compiled': compiled})
    return g

def make_grammar(gd):
    '''
    take a grammar data and make the grammar
    as it is used in line parsing function
    '''
    g = []
    for f, x in gd:
        # prepare the regular expression for the object f, x
        
        # possibly whitespace at the beginning:
        pattern = r'\s*'
        # x times a digit sequence followed by at least one space
        pattern += r'(\-?[0-9]+)\s+' * x
        # the command name at the end:
        pattern += f
        # compile the pattern:
        compiled = re.compile(pattern)
        # in the resulting grammar we retain the command and number of parameters:
        g.append({'command': f, 'n': x, 'pattern': pattern, 'compiled': compiled})
    return g

def repr_lines(ll):
    '''
    represent a list of lines (with full lines strings) as a string
    '''
    sl = []
    for line_struct in ll:
        sl.append('%3d: %s' % (line_struct['n'], line_struct['l']))
    r = '\n'.join(sl)
    return r

def init():
    grammar = make_grammar(grammar_data)

    return grammar

grammar = init()
meta_grammar = make_meta_grammar(meta_grammar_data)

if __name__ == '__main__':

    
    for gl in grammar:
        # ~ log_lib.debug(gl)
        pass

    for gl in meta_grammar:
        log_lib.debug(gl)
        pass

    
    # ~ en = 'qagb.1807.eps'
    # small:
    # ~ en = 'qagb.0132.eps'
    # middle:
    en = 'qagb.1809.eps'
    # ~ en = 'qagb.0534.eps'
    # ~ en = 'qagb.1093.eps'
    with open(en, 'r') as fh:
        s = fh.read()
    
    
    r = parse_eps(s)
    b = r['body']
    m = r['meta']
    log_lib.debug(m)
    # ~ b = {'ok': ok, 'us': us}
    if b['ok']:
        pass
        # ~ for u in b['us']:
            # ~ log_lib.debug(u)
    else:
        log_lib.error('error in parsing body')