#!/usr/bin/python3
# -*- coding: utf-8 -*-
'''
OTI->FEA

Genereates feature file (.fea) based on information from .oti file;
supported features:
* smcp and c2sc
* mark and mkmk

'''

__author__ = "Piotr Strzelczyk and Bogus/law Jackowski"
__copyright__ = "Copyright (c) 2017 by GUST e-foundry"
__credits__ = ["Piotr Strzelczyk", "Bogus/law Jackowski", "Piotr Pianowski"]
__license__ = "GPL"
__version__ = "0.1"
__maintainer__ = "Piotr Strzelczyk"
__email__ = "piotr@eps.gda.pl"
__status__ = "Beta"

# standard library:
import os
import sys
import string
import re
import textwrap
# for dictionaries with default values:
from collections import defaultdict

# this system library:
# reading and (some) parsing of oti file:
import algotype.ffdklib3 as ffdklib3
import algotype.log_lib as log_lib

template_patern = "##LOOKUPS##"

# ------------------------------------------------------------------------------
#.addLookup(new-lookup-name,type,flags, feature-script-lang-tuple [,after-lookup-name])
# feature-script-lang-tuple = ( ("liga", ( ("latn",("dflt",) ), ) ), )
#                             1 2feat    3 4script 5lang   5 4  3 2  1
# ligatures are added by FEA file
#if 'LIG' in inf:
#    lig = inf['LIG'].split()
#    glyph.addPosSub('ligatures0',lig)
#font.addLookup('ligatures', 'gsub_ligature', (), (("liga", (("DFLT", ("dflt",)),("latn", ("dflt",)))),) )
#font.addLookupSubtable('ligatures', 'ligatures0')



# ------------------------------------------------------------------------------

# a dictionary from keys, being (some) glyph names
# in the naming regime of glyphs generated by metapost
# to names of their lowercase versions (or None, if there is no lowercase)
sc_lower = {
    'idotaccent': None,
    'jdotaccent': None,
}

# a dictionary from keys, being (some) glyph names
# in the naming regime of glyphs generated by metapost
# to names of their uppercase versions (or None, if there is no uppercase)
sc_upper = {
    'ae': 'AE',
    'aeacute': 'AEacute',
    'dotlessi': None,
    'dotlessj': None,
    'eturned': None,
    'ij': 'IJ',
    'imacron.alt': 'Imacron.alt',
    'jcaron': None,
    'oe': 'OE',
}

mark_lookups = [
    ('markccmp', 'ccmped', ('ALT.comma', 'ALT.caron'), None),
    ('marktopdot', 'dotabove', 'ALT.dota', 'marktoplow'),
    ('marktoplow', 'top_accl', 'TOP_MAIN', None),
    ('marktopupp', 'top_accu', None, 'marktoplow'),
    ('markbotogon', 'ogon_acc', 'ALT.ogonek', 'markbotmain'),
    ('markbotdot', 'dotbelow', 'ALT.dotb', 'markbotmain'),
    ('markbotmain', 'bot_acc', 'BOT_MAIN', None),
]

mkmk_lookups = [
    ('mkmktophook', 'mk_hookacc', 'ALT.hook', 'mkmktoplow'),
    ('mkmktoplow', 'mk_top_acl', 'TOP_MAIN', None),
    ('mkmktopupp', 'mk_top_acu',  None, 'mkmktoplow'),
    ('mkmkbotogon', 'mk_ogon_acc', 'ALT.ogonek', 'mkmkbotmain'),
    ('mkmkbotmain', 'mk_bot_acc', 'BOT_MAIN', None),
]

mark_clases_id = {
    'INBAS':'markbase',
    'TOBAS':'markclass',
    'INACC':'mkmkbase',
    'TOACC':'mkmkclass',
    }

glyphs_not_accented = frozenset((
    'Imacron.alt',
    'imacron.alt',
    'cyrBreve',
    'cyrbreve',
    'asciitilde',
    'minus_tilde',
    'not_tilde',
    'triple_tilde',
    ));


# ------------------------------------------------------------------------------
# some sort of library functions:
# ------------------------------------------------------------------------------



def make_tuple(v):
    '''
    translate a value v of a type different then list or tuple
        to a singleton tuple
    and if v is a list or tuple -- return v
    the name of this function is wrong:
        for v being a list -- the list is returned, not tuple
    '''
    if isinstance(v, tuple) or isinstance(v, list):
        return v
    else:
        return (v,)






# ------------------------------------------------------------------------------
# the main feature generation functions:
# ------------------------------------------------------------------------------





def subs_classes(glyphs):
    '''
    I [MR] do not know yet, what is the purpose of this function
    
    input:
    oti_gly structure as received from the oti parser (read_oti)
    
    output:
    a list of strings (lines)
    representing a part of the resulting feature file
    the lines will be further inserted into the feature template string
    and will become a part of the feature file
    '''
    
    # start collecting lists of logical elements
    # defining subs_classes, whatever it means:
    scbasl = []
    scothl = []
    scsmcl = []
    sccscl = []
    # probably some math structure:
    mtl = []
    
    # collecting the information in five groups:
    for gln in glyphs:
        # gln is a glyph name being one of the keys/indexes
        # from the oti_gly (glyphs) dictionary:
        if gln.find('.') > 0:
            # the dot in the glyph name is present
            # and not in the initial position (not index 0):
            glnb, gle = gln.rsplit('.', 1)
            # glnb is a glyph basename, gle is the glypn name extension
            if gle == 'sc':
                # prepare:
                # gln – the original glyph name
                # glnb — glyph name base, basename
                # glnu — glyph name uppercase
                
                # the extension name is 'sc', meaning small caps (probably):
                if glnb in sc_upper:
                    # special case for glyphs of names found in sc_upper
                    # those are dotless i and j, some ae, oe ligatures etc.:
                    glnu = sc_upper[glnb]
                else:
                    glnu = glnb.title()
                    
                if glnb in sc_lower:
                    # special case for glyphs of names found in sc_lower
                    # those are i and j dot accents that do not have sc variant:
                    glnb = sc_lower[glnb]
                    
                # if glnb (string name of the current glyph) is not empty
                # but is not present in the glyphs dictionary
                # make the warning:
                if glnb and glnb not in glyphs:
                    log_lib.warning('No base char %s for %s' % (glnb, gln))
                    continue
                    
                # if glnu (string name of the uppercase version
                #   of current glyph) is not empty
                # but is not present in the glyphs dictionary
                # make the warning:
                if glnu and glnu not in glyphs:
                    log_lib.warning('No upper base char %s for %s' % (glnu, gln))
                    continue
                    
                if glnb and glnu:
                    # both basename and upercase name are nonempty:
                    if len(glnb) == 1:
                        scbasl.append((glnb, glnu, gln))
                    else:
                        scothl.append((glnb, glnu, gln))
                elif glnb:
                    scsmcl.append((glnb, gln))
                elif glnu:
                    sccscl.append((glnu, gln))

            elif gle == 'mt':
                # extension of the glyph name is 'mt':
                
                # make sure the glypch with the base name also exists:
                if glnb not in glyphs:
                    log_lib.warning('No base char %s for %s' % (glnb, gln))
                    continue
                    
                # in the correct case, append the information
                # to the mtl structure
                mtl.append((glnb, gln))
                
    # sort some of the logical elements:
    scbasl.sort(key=lambda x: x[0])
    scothl.sort(key=lambda x: x[0])
    mtl.sort(key=lambda x: x[0])

    if 0:
        # sometimes test prints:
        print('scbasl')
        print(repr_list(scbasl))
        print('scothl')
        print(repr_list(scothl))
        print('scsmcl')
        print(repr_list(scsmcl))
        print('sccscl')
        print(repr_list(sccscl))
        print('mtl')
        print(repr_list(mtl))
    
    # a step of serialization of the collected logical elements:
    letsmabas = '@letsmabas=[%s];' %  (' '.join([g[0] for g in scbasl]),)
    letcapbas = '@letcapbas=[%s];' %  (' '.join([g[1] for g in scbasl]),)
    letcscbas = '@letcscbas=[%s];' %  (' '.join([g[2] for g in scbasl]),)

    # why the order of serialization is different?
    letcapoth = '@letcapoth=[%s];' %  (' '.join([g[1] for g in scothl]),)
    letsmaoth = '@letsmaoth=[%s];' %  (' '.join([g[0] for g in scothl]),)
    letcscoth = '@letcscoth=[%s];' %  (' '.join([g[2] for g in scothl]),)
    
    letsmaotx = '@letsmaotx=[%s];' %  (' '.join([g[0] for g in scsmcl]),)
    letcscotx = '@letcscotx=[%s];' %  (' '.join([g[1] for g in scsmcl]),)
    
    letcapoty = '@letcapoty=[%s];' %  (' '.join([g[0] for g in sccscl]),)
    letcscoty = '@letcscoty=[%s];' %  (' '.join([g[1] for g in sccscl]),)
    
    mathm = '@mathm=[%s];' %  (' '.join([g[1] for g in mtl]),)
    matht = '@matht=[%s];' %  (' '.join([g[0] for g in mtl]),)
    
    # prepare the result res as a list of strings:
    res=[]
    
    res.extend(textwrap.wrap(letsmabas));
    res.extend(textwrap.wrap(letcapbas));
    res.extend(textwrap.wrap(letcscbas)); res.append('')
    
    res.extend(textwrap.wrap(letcapoth)); res.append('')
    res.extend(textwrap.wrap(letsmaoth)); res.append('')
    res.extend(textwrap.wrap(letcscoth)); res.append('')
    
    res.extend(textwrap.wrap(letsmaotx));
    res.extend(textwrap.wrap(letcscotx)); res.append('')
    
    res.extend(textwrap.wrap(letcapoty));
    res.extend(textwrap.wrap(letcscoty)); res.append('')
    
    res.extend(textwrap.wrap(mathm)); res.append('')
    res.extend(textwrap.wrap(matht)); res.append(''); res.append('')
    
    # and return the resulting list of strings:
    return res

def repr_list(l):
    '''
    represent a list of some type of elements
    (probably shorter then one line)
    '''
    sl = []
    for e in l:
        sl.append(str(e))
    s = '\n'.join(sl)
    return s

# for sorting lookups
def mk_key(l):
    '''
    return a sorting key
    for sorting lookups
    l is a table line (before line wrapping)
    '''
    if isinstance(l, tuple):
        gln = l[0]
    else:
        gln = l
    if not gln.islower():
        gln = '1' + gln
    if gln.find('dotless') == 0:
        gln = 'zz' + gln
    if gln.find('.sc') > 0:
        gln = 'z' + gln
    return gln


def anchor_lookup(glyphs, gdef_l):

    # collecting data structures:
    idatolook = {}
    MARKS = {}

    for i in list(mark_clases_id.values()):
        idatolook[i]={}
        
    for l in mark_lookups:
        for v in make_tuple(l[2]):
            if v:
                idatolook['markclass'][v] = l[0]
                idatolook['markbase'][v] = l[0]
            MARKS[l[0]] = {'markclass': {}, 'markbase': {}}
    for l in mkmk_lookups:
        for v in make_tuple(l[2]):
            if v:
                idatolook['mkmkclass'][v] = l[0]
                idatolook['mkmkbase'][v] = l[0]
            MARKS[l[0]] = {'mkmkclass': {}, 'mkmkbase': {}}
            
    for gln in glyphs:
        if 'ANCHOR' in glyphs[gln]:
            for cls, anchd in list(glyphs[gln]['ANCHOR'].items()):
                for ida, coord in list(anchd.items()):
                    #print gln, cls, ida, coord
                    if cls in mark_clases_id:
                        mid = mark_clases_id[cls]
                        look = idatolook[mid][ida]
                        if gln in MARKS[look][mid]:
                            log_lib.warning('Double anchor %s in %s' % (ida, gln))
                        else:
                            MARKS[look][mid][gln] = ' '.join(coord)
                    else:
                        log_lib.warning('Unknown class %s' % (cls,))
    #
    # MARKS[look][mid][gln] = [position of anchor]
    #                  ^ glyphname
    #             ^ mark clases type (base or accent, mark or mkmk)
    #       ^ lookup name

    # splitting lookups
    for ll in (mark_lookups, mkmk_lookups):
      for l in ll:
          if l[3] != None:
            if l[2] != None:
              lid=l[0]; lfr=l[3]
              for mid in MARKS[lfr]:
                if mid in ('markclass', 'mkmkclass'):
                  for gln in list(MARKS[lfr][mid]):
                      if gln in MARKS[lid][mid]:
                          if MARKS[lfr][mid][gln]==MARKS[lid][mid][gln]:
                              del MARKS[lfr][mid][gln]
                          else:
                              log_lib.warning('Not matching anchors in %s (%s not equal to %s)' % (gln,lfr,lid))
                else:
                  for gln in list(MARKS[lfr][mid]):
                      if gln not in MARKS[lid][mid]:
                           MARKS[lid][mid][gln]=MARKS[lfr][mid][gln]
            else:
              lid=l[0]; lfr=l[3]
              for mid in MARKS[lfr]:
                  for gln in list(MARKS[lfr][mid]):
                     if lid in ('marktopupp', 'mkmktopupp'):
                         if not gln.islower() or gln in ('b' 'd' 'h' 'k' 'l') or (mid == 'markclass'):
                           MARKS[lid][mid][gln]=MARKS[lfr][mid][gln]
                           if (mid != 'markclass') or not gln.islower():
                             del MARKS[lfr][mid][gln]

    # sorting lookups
    MARKSL={}
    gdef_s=defaultdict(int); gdef_m=defaultdict(int);
    for ll in (mark_lookups, mkmk_lookups):
      for l in ll:
        lid=l[0]; ide=l[1]
        classlst=[]; baselst=[]
        for mid in MARKS[lid]:
            for gln,cor in list(MARKS[lid][mid].items()):
                if mid in ('markclass', 'mkmkclass'):
                    classlst.append((gln, 'markClass [%s] <anchor %s> @%s;' % (gln, cor, ide)))
                    gdef_m[gln]+=1
                elif mid in ('markbase'):
                    baselst.append((gln, 'position base [%s] <anchor %s> mark @%s;' % (gln, cor, ide)))
                    gdef_s[gln]+=1
                else: # mid == 'mkmkbase'
                    baselst.append((gln, 'position mark [%s] <anchor %s> mark @%s;' % (gln, cor, ide)))
        if (len(classlst)>0 and len(baselst)>0):
            classlst.sort(key=mk_key)
            baselst.sort(key=mk_key)
            MARKSL[lid]=classlst
            MARKSL[lid].extend(baselst)
        else:
            log_lib.warning("Empty mark lookup: %s" % lid)

    # creating result features lines
    res = []
    for ll in (mark_lookups, mkmk_lookups):
      for l in ll:
        lid=l[0]
        if lid in MARKSL:
          res.append('lookup %s {' % (lid,))
          for v in MARKSL[lid]:
              res.append('  ' + v[1])
          res.append('} %s;' % (lid,))
          res.append('')

    res.append('feature mark { # Base to mark')
    for l in mark_lookups:
        if l[0] in MARKSL:
            res.append('  lookup %s;' % (l[0],))
    res.append('} mark;')
    res.append('')
    res.append('feature mkmk { # Mark to mark')
    for l in mkmk_lookups:
        if l[0] in MARKSL:
            res.append('  lookup %s;' % (l[0],))
    res.append('} mkmk;')
    res.append('')

    # creating GDEF table lines
    gdef_s=list(gdef_s); gdef_s.sort(key=mk_key)
    gdef_l=list(gdef_l); gdef_l.sort(key=mk_key)
    gdef_m=list(gdef_m); gdef_m.sort(key=mk_key)
    gdef_ss='@GDEF_Simple=[%s];' % (' '.join(gdef_s),)
    gdef_ls='@GDEF_Ligat=[%s];' % (' '.join(gdef_l),)
    gdef_ms='@GDEF_Mark=[%s];' % (' '.join(gdef_m),)
    res_gd=[]
    res_gd.extend(textwrap.wrap(gdef_ss));
    res_gd.extend(textwrap.wrap(gdef_ls));
    res_gd.extend(textwrap.wrap(gdef_ms));
    res_gd.append('')
    res_gd.append('table GDEF {')
    res_gd.append('  GlyphClassDef @GDEF_Simple, @GDEF_Ligat, @GDEF_Mark, ;')
    res_gd.append('} GDEF;')
    res_gd.append('')

    return res, res_gd, gdef_m



def deccmp_lookup(glyphs, mark_lst):
    piotr = False
    if piotr:
        mark_re = '';
        for m in mark_lst:
            mb = re.sub('comb(\.[a-z]+)?$', '', m)
            if mb in ('ogonek', 'cedilla', 'horn', 'slash'):
                continue
            if mark_re:
                mark_re = mark_re + '|'
            else:
                mark_re ='^(.*?)('
            mark_re = mark_re + mb
        mark_re = mark_re + ')$'
        # ~ print('mark re = %s' % mark_re)
    else:
        mark_re = '';
        for m in mark_lst:
            mb = re.sub('comb(\.[a-z]+)?$', '', m)
            if mb in ('ogonek', 'cedilla', 'horn', 'slash'):
                continue
            if mark_re:
                mark_re = mark_re + '|'
            else:
                mark_re ='^(.*?)('
            mark_re = mark_re + mb
        if mark_re:
            mark_re = mark_re + ')$'
        # ~ print('mark re = %s' % mark_re)
    
    
    de_comps = []
    for gln in glyphs:
        if gln in glyphs_not_accented:
            continue
        if gln.find('.')>0:
            glnb, gle = gln.rsplit('.',1)
            gle = '.' + gle
        else:
            glnb = gln
            gle=''

        # collecting marks:
        marks = []
        if piotr:
            while True:
                m = re.match(mark_re, glnb)
                if not m:
                    break
                glnb = m.group(1)
                mark = m.group(2) + 'comb'
                if not glnb.islower() and ('below' not in mark) and mark != 'commaaccentcomb':
                   mark = mark.title()
                   if mark == 'Dblgravecomb':
                       mark = 'dblGravecomb'
                if mark not in glyphs:
                    log_lib.warning('Not existing accent spotted: %s (it can\'t happen)' % (mark))
                marks.insert(0, mark)
        else:
            if mark_re:
                while True:
                    m = re.match(mark_re, glnb)
                    if not m:
                        break
                    glnb = m.group(1)
                    mark = m.group(2) + 'comb'
                    if not glnb.islower() and ('below' not in mark) and mark != 'commaaccentcomb':
                       mark = mark.title()
                       if mark == 'Dblgravecomb':
                           mark = 'dblGravecomb'
                    if mark not in glyphs:
                        log_lib.warning('Not existing accent spotted: %s (it can\'t happen)' % (mark))
                    marks.insert(0, mark)
                
        if marks and glnb:
           glnb = glnb + gle
           if glnb in ('J_',): glnb = glnb.rstrip('_')
           if glnb in ('i','j'): glnb = 'dotless' + glnb
           if glnb in glyphs:
               decomp='  sub %s by %s %s;' % (gln, glnb, ' '.join(marks))
               de_comps.append((gln, decomp))
           else:
               log_lib.warning('Not existing base letter spotted: %s (+%s, it should be an exception)' % (glnb, marks[0].replace('comb','')))

    de_comps.sort(key=mk_key)
    de_compl= [v[0] for v in de_comps]
    de_comp_class='@let_decomp=[%s];' %  (' '.join(de_compl),)
    res = []
    res.append('lookup ccmp_decomp_sub {')
    for v in de_comps:
        res.append(v[1])
    res.append('} ccmp_decomp_sub;')
    res.append('')
    res.extend(textwrap.wrap(de_comp_class));
    res.append('')
    return res


def read_template(tname):
    try:
        # ftpl = file(tname, 'r')
        # 21.02.2019 03:30:58
        ftpl = open(tname, 'r')
    except IOError:
        log_lib.critical("Couldn't find TEMPLATE file: %s" % tname)
        return [template_patern]
    template = []
    waslookup=False
    for line in ftpl.readlines():
        line = line.rstrip() # remove DOS/UNIX EOLs
        if line==template_patern:
            waslookup=True
        template.append(line)
    if not waslookup:
        temp = []
        for line in template:
            if (line != '') and (line.find('#')!=0):
                temp.append(template_patern)
            temp.append(line)
        template=temp
    return template

def find_ligatures(template):
    gdef_l = defaultdict(int)
    for line in template:
        line = re.sub(' *#.*$', '', line)
        linem = re.match(r' +sub +([A-Za-z]+[A-Za-z_\.]*) +([A-Za-z]+[A-Za-z_\.]* +)+by +(?P<ligature>[A-Za-z]+[A-Za-z_\.]*);', line)
        if linem:
            gdef_l[linem.group('ligature')] += 1
    return gdef_l


def fea_write(s, oname):

    

    try:
        with open(oname, 'w') as fh:
            fh.write(s)
    except IOError:
        log_lib.critical("Couldn't open FEA file: %s" % oname)
        return
        
    


    # for line in template:
        # if line==template_patern:
            # for l in csc_classes:
                # print(l, file=ffea)
            # for l in mark_lookups:
                # print(l, file=ffea)
            # for l in gdef_table:
                # print(l, file=ffea)
            # for l in ccmp_lookup:
                # print(l, file=ffea)
        # else:
            # print(line, file=ffea)

def fea_string_generate(template, csc_classes, mark_lookups, gdef_table, ccmp_lookup):
    sl = []
    for line in template:
        if line == template_patern:
            # in the special place in the template pattern
            # put lines of text from the four string lists
            sl.extend(csc_classes)
            sl.extend(mark_lookups)
            sl.extend(gdef_table)
            sl.extend(ccmp_lookup)
        else:
            sl.append(line)
            
    s = '\n'.join(sl)
    return s



#
# Start of processing:
#

        
def fea_string_prepare(oti_gly, template):
    '''
    generate a feature file string
    using information from oti_gly structure, as read from oti file
    and using a feature text template, in the form of a list of strings
    
    07.09.2019 16:56:43
    '''
    # the main fea file generation:
    csc_classes = subs_classes(oti_gly)
    mark_lookups, gdef_table, mark_lst = anchor_lookup(oti_gly, find_ligatures(template))
    ccmp_lookup =  deccmp_lookup(oti_gly, mark_lst)
    # prepare the fea file string:
    s = fea_string_generate(template, csc_classes, mark_lookups, gdef_table, ccmp_lookup)
    return s


def main(inp, template_name, output, q=True):
    global quiet
    quiet = q
    
    iname = inp.strip()
    iname = re.sub(r'\.[^\.]+$', '.oti', iname)
    oname = output
    
    # to respect the ”quiet” parameter:
    log_lib.info("OTI < " + iname)

    oti = ffdklib3.read_oti(iname)
    # oti_fnt = oti['font']
    oti_gly = oti['glyphs']
    # glyn_lst = oti['list']

    # prepare the name of the feature template file
    if template_name:
        template_name = template_name.strip()
        # to respect the “quiet” parameter:
        log_lib.info("TPL < %s" % template_name)
        template = read_template(template_name)
    else:
        template = [template_patern]
    # template is a list of strings
    # (possibly a single-string list or more then 300 strings)

    # prepare the name of the output feature file:
    # in future it should be defined in the config file
    # and generate the fea file for this output filename:
    if oname:
        # the output is specified (may be empty or just whitespace):
        oname = oname.strip()
        # if oname == '':
        if len(oname) == 0:
            oname = iname.replace('.oti', '.fea', '')
        # to respect the “quiet” parameter:
        log_lib.info("FEA > %s" % oname)
        s = fea_string_prepare(oti_gly, template)
        fea_write(s, oname)
