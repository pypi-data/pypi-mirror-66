# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['lambdarest']

package_data = \
{'': ['*']}

install_requires = \
['jsonschema>=3.2.0,<4.0.0', 'strict_rfc3339>=0.7,<0.8', 'werkzeug==0.16.1']

setup_kwargs = {
    'name': 'lambdarest',
    'version': '9.1.1',
    'description': 'flask like web framework for AWS Lambda',
    'long_description': '# lambdarest\n\n[![Build Status](https://travis-ci.org/trustpilot/python-lambdarest.svg?branch=master)](https://travis-ci.org/trustpilot/python-lambdarest) [![Latest Version](https://img.shields.io/pypi/v/lambdarest.svg)](https://pypi.python.org/pypi/lambdarest) [![Python Support](https://img.shields.io/pypi/pyversions/lambdarest.svg)](https://pypi.python.org/pypi/lambdarest) [![Examples tested with pytest-readme](http://img.shields.io/badge/readme-tested-brightgreen.svg)](https://github.com/boxed/pytest-readme)\n\n\nPython routing mini-framework for [AWS Lambda](https://aws.amazon.com/lambda/) with optional JSON-schema validation.\n\n### Features\n\n* `lambda_handler` function constructor with built-in dispatcher\n* Decorator to register functions to handle HTTP methods\n* Optional JSON-schema input validation using same decorator\n\n### External articles / tutorials\n\n* [devgrok.com: Create a Private Microservice Using an Application Load Balancer](http://www.devgrok.com/2019/03/create-private-microservice-using.html)\n\n  Article about how to use **lambdarest** with **AWS Application Load Balancer**\n\n* [rockset.com: Building a Serverless Microservice Using Rockset and AWS Lambda](https://rockset.com/blog/building-a-serverless-microservice-using-rockset-and-aws-lambda/)\n\n  Article about how to set up **lambdarest** in AWS infrastructure\n\n**Other articles? add them [here](https://github.com/trustpilot/python-lambdarest/issues/55)**\n\n## Installation\n\nInstall the package from [PyPI](http://pypi.python.org/pypi/) using [pip](https://pip.pypa.io/):\n\n```bash\n$ pip install lambdarest\n```\n\n## Getting Started\n\nThis module helps you to handle different HTTP methods in your AWS Lambda.\n\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get")\ndef my_own_get(event):\n    return {"this": "will be json dumped"}\n\n\n##### TEST #####\n\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/"\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"this": "will be json dumped"}\', "statusCode": 200, "headers":{}}\n```\n\n## Advanced Usage\n\nOptionally you can validate an incoming JSON body against a JSON schema:\n\n```python\nfrom lambdarest import lambda_handler\n\nmy_schema = {\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "type": "object",\n    "properties": {\n        "body":{\n            "type": "object",\n            "properties": {\n                "foo": {\n                    "type": "string"\n                }\n            }\n        }\n    }\n}\n\n@lambda_handler.handle("get", path="/with-schema/", schema=my_schema)\ndef my_own_get(event):\n    return {"this": "will be json dumped"}\n\n\n##### TEST #####\n\n\nvalid_input_event = {\n    "body": \'{"foo":"bar"}\',\n    "httpMethod": "GET",\n    "resource": "/with-schema/"\n}\nresult = lambda_handler(event=valid_input_event)\nassert result == {"body": \'{"this": "will be json dumped"}\', "statusCode": 200, "headers":{}}\n\n\ninvalid_input_event = {\n    "body": \'{"foo":666}\',\n    "httpMethod": "GET",\n    "resource": "/with-schema/"\n}\nresult = lambda_handler(event=invalid_input_event)\nassert result == {"body": \'Validation Error\', "statusCode": 400, "headers":{}}\n```\n\n### Query Params\n\nQuery parameters are also analyzed and validatable with JSON schemas.\nQuery arrays are expected to be comma separated, all numbers are converted to floats.\n\n```python\nfrom lambdarest import lambda_handler\n\nmy_schema = {\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "type": "object",\n    "properties": {\n        "query":{\n            "type": "object",\n            "properties": {\n                "foo": {\n                    "type": "array",\n                    "items": {\n                        "type": "number"\n                    }\n                }\n            }\n        }\n    }\n}\n\n@lambda_handler.handle("get", path="/with-params/", schema=my_schema)\ndef my_own_get(event):\n    return event["json"]["query"]\n\n\n##### TEST #####\n\n\nvalid_input_event = {\n    "queryStringParameters": {\n        "foo": "1, 2.2, 3"\n    },\n    "httpMethod": "GET",\n    "resource": "/with-params/"\n}\nresult = lambda_handler(event=valid_input_event)\nassert result == {"body": \'{"foo": [1.0, 2.2, 3.0]}\', "statusCode": 200, "headers":{}}\n```\n\n### Routing\n\nYou can also specify which path to react on for individual handlers using the `path` param:\n\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/foo/bar/baz")\ndef my_own_get(event):\n    return {"this": "will be json dumped"}\n\n\n##### TEST #####\n\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/foo/bar/baz"\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"this": "will be json dumped"}\', "statusCode": 200, "headers":{}}\n```\n\nAnd you can specify path parameters as well, which will be passed as keyword arguments:\n\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/foo/<int:id>/")\ndef my_own_get(event, id):\n    return {"my-id": id}\n\n\n##### TEST #####\n\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/foo/1234/"\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"my-id": 1234}\', "statusCode": 200, "headers":{}}\n```\n\nOr you can specify more complex parametrized resource path and get parameteres as arguments:\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/object/<int:object_id>/props/<string:foo>/get")\ndef my_own_get(event, object_id, foo):\n    return [{"object_id": int(object_id)}, {"foo": foo}]\n\n\n##### TEST #####\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "path": "/v1/object/777/props/bar/get",\n    "resource": "/object/{object_id}/props/{foo}/get",\n    "pathParameters": {\n      "object_id": "777",\n      "foo":"bar"\n    }\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'[{"object_id": 777}, {"foo": "bar"}]\', "statusCode": 200, "headers":{}}\n\n```\nOr use the Proxy APIGateway magic endpoint:\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/bar/<path:path>")\ndef my_own_get(event, path):\n    return {"path": path}\n\n\n##### TEST #####\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "path": "/v1/bar/baz",\n    "resource": "/bar/{proxy+}",\n    "pathParameters": {\n      "proxy": "bar/baz"\n    }\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"path": "bar/baz"}\', "statusCode": 200, "headers":{}}\n```\n\n### Scopes\n\nIf you\'re using a Lambda authorizer, you can pass authorization scopes as input into your Lambda function.\n\nThis is useful when using the API Gateway with a Lambda authorizer and have the Lambda authorizer return in a scopes json object the permissions (scopes) the caller has access to. In your Lambda function you can specify what scopes the caller should have to call that function. If the requested scope was not provided by the Lambda authorizer, a 403 error code is given.\n\nThe API gateway has the limitation it can only pass primitive data types from a Lambda authorizer function. The scopes list therefore needs to be json encoded by the authorizer function.\n\nTo use this, add a scopes attribute to the handler with the list of scopes your function requires. They will be verified from the requestContext.authorizer.scopes attribute from the Lambda authorizer.\n\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/private1", scopes=["myresource.read"])\ndef my_own_get(event):\n    return {"this": "will be json dumped"}\n\n##### TEST #####\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/private1",\n    "requestContext": {\n        "authorizer": {\n            "scopes": \'["myresource.read"]\'\n        }\n    }\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"this": "will be json dumped"}\', "statusCode": 200, "headers":{}}\n```\nWhen no scopes are provided by the authorizer but are still requested by your function, a permission denied error is returned.\n```python\nfrom lambdarest import lambda_handler\n\n@lambda_handler.handle("get", path="/private2", scopes=["myresource.read"])\ndef my_own_get(event):\n    return {"this": "will be json dumped"}\n\n##### TEST #####\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/private2"\n}\nresult = lambda_handler(event=input_event)\nprint(result)\nassert result == {"body": "Permission denied", "statusCode": 403, "headers":{}}\n```\n\n## Use it with AWS Application Load Balancer\n\nIn order to use it with Application Load Balancer you need to create your own lambda_handler and not use the singleton:\n\n```python\nfrom lambdarest import create_lambda_handler\n\nlambda_handler = create_lambda_handler(application_load_balancer=True)\n\n@lambda_handler.handle("get", path="/foo/<int:id>/")\ndef my_own_get(event, id):\n    return {"my-id": id}\n\n\n##### TEST #####\n\n\ninput_event = {\n    "body": \'{}\',\n    "httpMethod": "GET",\n    "resource": "/foo/1234/"\n}\nresult = lambda_handler(event=input_event)\nassert result == {"body": \'{"my-id": 1234}\', "statusCode": 200, "headers":{}, "statusDescription": "HTTP OK", "isBase64Encoded": False}\n```\n\n## Anormal unittest behaviour with `lambda_handler` singleton\n\nBecause of python unittests leaky test-cases it seems like you shall beware of [this issue](https://github.com/trustpilot/python-lambdarest/issues/16) when using the singleton `lambda_handler` in a multiple test-case scenario.\n\n## Tests\n\nThis package uses [Poetry](https://python-poetry.org/docs/) to install requirements and run tests.\n\nUse the following commands to install requirements and run test-suite:\n\n```bash\n$ poetry install\n$ poetry run task test\n```\n\nFor more info see [Contributing...](./CONTRIBUTING.md)\n\n## Changelog\n\nSee [HISTORY.md](https://github.com/trustpilot/python-lambdarest/blob/master/HISTORY.md)\n\n## Contributors\n\n@mkreg @aphexer @nabrosimoff, @elviejokike, @eduardomourar, @devgrok, @AlbertoTrindade, @paddie, @svdgraaf, @simongarnier, @martinbuberl, @adamelmore, @sloev\n\n[Wanna contribute?](./CONTRIBUTING.md)\n\nAnd by the way, we have a [Code Of Friendlyhood!](./CODE_OF_CONDUCT.md)\n',
    'author': 'Johannes ValbjÃ¸rn',
    'author_email': 'jgv@trustpilot.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/trustpilot/python-lambdarest',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
