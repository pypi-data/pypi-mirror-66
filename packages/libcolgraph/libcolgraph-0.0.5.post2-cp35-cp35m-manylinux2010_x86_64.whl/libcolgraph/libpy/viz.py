#! /bin/env/ python3

import pyvis
import json
import math
import io
import urllib, base64

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

from ..libcolgraph import *


def get_piechart(hexcolors):
    '''
    given a list of colors in hex, returns an equally spaced out piechart
    with all those colors, in the form
    '''
    plt.ioff()
    plt.pie([1 for _ in hexcolors], colors=[*sorted(hexcolors)], startangle=0,
            radius=2)

    # trick pyplot into saving a file in a buffer so we can use it later
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png', transparent=True)
    plt.close('all')

    buffer.seek(0)
    # encode it in base64 as visJS needs it
    imgstr = base64.b64encode(buffer.read())
    datauri = 'data:image/png;base64,' + urllib.parse.quote(imgstr)

    return datauri


def to_pyvis_network(g, *args, **kwargs):
    '''
    method to return a pyvis Network object from Graph<> `g`
    '''
    net = pyvis.network.Network()
    for v in g.get_vertices():
        net.add_node(v.get_name(), size=32*math.pow(len(v), 1/3),
                     group=str(len(v)))

    for v in g.get_vertices():
        try:
            for nname in v.get_neighbors():
                net.add_edge(v.get_name(), nname)
        except IndexError as e:
            continue

    return net


def _to_visjs(g, colordict={1: '#039be5', 0: '#ef5350'},
             colorfn=None, *args, **kwargs):
    '''
    '''
    nodes = {}
    edges = {}

    for v in g.get_vertices():
        name = v.get_name()
        nodes[name] = {
                        'id': name,
                        'label': str(name),
                        'size': 32*math.pow(len(v), 1/3),
                        'group': str(len(v)),
                        'shape': 'dot',
                      }

        if colorfn and type(colorfn(v)) is str:
            nodes[name]['color'] = colordict[colorfn(v)]
            nodes[name]['label'] += ' ' + nodes[name]['color']
        elif 'Base' in str(type(g)):
            if colorfn and type(colorfn(v)) is list:
                nodes[name]['shape'] = 'image'
                nodes[name]['image'] = get_piechart([colordict[c]
                                                     for c in colorfn(v)])
            else:
                nodes[name]['shape'] = 'triangle'

        if hasattr(g, 'locations'):
            nodes[name]['x'], nodes[name]['y'] = g.locations[name]

        for n in v.get_neighbors():
            edge = tuple(sorted([name, n]))
            if edge in edges:
                continue

            edges[edge] = {
                            'from': edge[0],
                            'to': edge[1],
                            'id': '%d %d' % edge,
                            'value': (len(g.get_vertex(edge[0]))
                                      * len(g.get_vertex(edge[1]))) ** .5,
                            'color': {'inherit': 'both', 'opacity': .95},
                          }

    nodes = [v for k, v in nodes.items()]
    edges = [v for k, v in edges.items()]

    return nodes, edges


def to_visjs(g, force_type=None, colordict={1: '#039be5', 2: '#ef5350'},
             colorfn=lambda v: 1+int(len(v)==1), pyvis=False, *args, **kwargs):
    '''
    takes in a graph which is a subclass of Graph<> (see GraphTemplates.h)
    and produces a json object that specifies how the graph should be plotted
    in a way that VisJS can use
    '''
    if pyvis:
        net = to_pyvis_network(g)
        nodes, edges, height, width, options = net.get_network_data()
    else:
        nodes, edges = _to_visjs(g, colordict=colordict, colorfn=colorfn,
                                 **kwargs)

    prefix = ''
    typestr = str(type(g))
    # print(typestr)
    if not force_type:
        if 'Base' in typestr: prefix = 'bg'
        elif 'Coloring' in typestr: prefix = 'cg'
        else: prefix = 'mcg'
    else:
        prefix=force_type

    data = {prefix+'nodes': json.dumps(nodes),
            prefix+'edges': json.dumps(edges)}

    return data



def from_visjs(data, *args, **kwargs):
    '''
    takes in data generated by visJS and converts it to a BaseGraph object
    '''
    g = BaseGraph()

    lookup = dict()
    for i, node in enumerate(data):
        lookup[node['id']] = i
        g.add_vertex(i)

    for node in data:
        for nbr in node['connections']:
            g.make_edge(lookup[node['id']], lookup[str(nbr)])

    g.locations = dict()
    for node in data:
        g.locations[lookup[node['id']]] = (node['x'], node['y'])

    return g
