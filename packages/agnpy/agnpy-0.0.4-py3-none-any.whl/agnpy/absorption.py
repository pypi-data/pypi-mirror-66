import numpy as np
import astropy.constants as const
import astropy.units as u
from .compton import cos_psi, x_re_shell, x_re_ring, mu_star


# every variable indicated with capital letters is unitless
# will be used in SED computations for speed-up
H = const.h.cgs.value
C = const.c.cgs.value
ME = const.m_e.cgs.value
MEC2 = (const.m_e * const.c * const.c).cgs.value
SIGMA_T = const.sigma_T.cgs.value


__all__ = ["sigma", "Absorption"]


def sigma(s):
    """photon-photon pair production cross section, Eq. 17 of [Dermer2009]"""
    beta_cm = np.sqrt(1 - np.power(s, -1))
    _prefactor = 3 / 16 * SIGMA_T * (1 - np.power(beta_cm, 2))
    _term1 = (3 - np.power(beta_cm, 4)) * np.log((1 + beta_cm) / (1 - beta_cm))
    _term2 = -2 * beta_cm * (2 - np.power(beta_cm, 2))
    values = _prefactor * (_term1 + _term2)
    values[s < 1] = 0
    return values


class Absorption:
    """class to compute the absorption due to gamma-gamma pair production

    Parameters
    ----------
    blob : :class:`~agnpy.emission_regions.Blob`
        emission region and electron distribution hitting the photon target
    target : :class:`~agnpy.targets`
        class describing the target photon field    
    r : :class:`~astropy.units.Quantity`
        distance of the blob from the Black Hole (i.e. from the target photons)

    Attributes
    ----------
    mu_min : float
        minimum cosine of the zenith angle subtended by the target photon field
    mu_max : float
        maximum cosine of the zenith angle subtended by the target photon field
    mu_size : int
        size of the array of the zenith dependence of the target field
    phi : array_like
        size of the array of the azimuth dependence of the target field
    """

    def __init__(self, blob, target, r):
        self.blob = blob
        self.target = target
        self.r = r.cgs
        self._r = self.r.value
        self.set_mu()
        self.set_phi()
        self.set_l()

    def set_mu(self, mu_size=100):
        self.mu_size = mu_size
        if self.target.type == "SSDisk":
            self.mu_min = 1 / np.sqrt(1 + np.power(self.target._R_out / self._r, 2))
            self.mu_max = 1 / np.sqrt(1 + np.power(self.target._R_in / self._r, 2))
        else:
            self.mu_min = -1
            self.mu_max = 1
        self.mu = np.linspace(self.mu_min, self.mu_max, self.mu_size)

    def set_phi(self, phi_size=50):
        self.phi_size = phi_size
        self.phi = np.linspace(0, 2 * np.pi, self.phi_size)

    def set_l(self, l_size=50):
        """set the range of integration for the distance
        """
        # integrate up to 10^22 cm i.e. roughly 3000 Pc
        self.l_size = l_size
        self.l = np.logspace(np.log10(self._r), 22, self.l_size)

    def _opacity_disk(self, nu):
        """opacity generated by a Shakura Sunyaev disk

        Parameters
        ----------
        nu : `~astropy.units.Quantity`
            array of frequencies, in Hz, to compute the sed, **note** these are 
            observed frequencies (observer frame).
        """
        # define the dimensionless energy
        epsilon_1_obs = H * nu.to("Hz").value / MEC2
        # transform to BH frame
        epsilon_1 = epsilon_1_obs * (1 + self.blob.z)
        # axis 0: mu
        # axis 1: phi
        # axis 2: l
        # axis 3: epsilon_1
        _mu_s = self.blob.mu_s
        _mu = self.mu.reshape(self.mu.size, 1, 1, 1)
        _phi = self.phi.reshape(1, self.phi.size, 1, 1)
        _l = self.l.reshape(1, 1, self.l.size, 1)
        _epsilon_1 = epsilon_1.reshape(1, 1, 1, epsilon_1.size)

        # epsilon and phi of the disk have the same dimensions of mu
        # this time though they do not depend on a fixed distance r, but
        # on the variable distance l
        _epsilon = self.target._epsilon_mu(_mu, _l)
        _phi_disk_mu = self.target._phi_disk_mu(_mu, _l)

        _cos_psi = cos_psi(_mu_s, _mu, _phi)
        _s = _epsilon_1 * _epsilon * (1 - _cos_psi) / 2
        _integrand_mu = _phi_disk_mu / (
            _epsilon * np.power(_l, 3) * np.power(np.power(_mu, -2) - 1, 3 / 2)
        )
        _integrand = (1 - _cos_psi) * _integrand_mu * sigma(_s)

        prefactor_num = 3 * self.target._L_disk * self.target._R_g
        prefactor_denum = 16 * np.pi * self.target.eta * ME * np.power(C, 3)

        integral_mu = np.trapz(_integrand, self.mu, axis=0)
        integral_phi = np.trapz(integral_mu, self.phi, axis=0)
        integral = np.trapz(integral_phi, self.l, axis=0)

        return prefactor_num / prefactor_denum * integral

    def _opacity_shell_blr(self, nu):
        """opacity generated by a spherical shell Broad Line Region

        Parameters
        ----------
        nu : `~astropy.units.Quantity`
            array of frequencies, in Hz, to compute the sed, **note** these are 
            observed frequencies (observer frame).
        """
        # define the dimensionless energy
        epsilon_1_obs = H * nu.to("Hz").value / MEC2
        # transform to BH frame
        epsilon_1 = epsilon_1_obs * (1 + self.blob.z)
        # axis 0: mu_re
        # axis 1: phi
        # axis 2: l
        # axis 3: epsilon_1
        _mu_s = self.blob.mu_s
        _mu = self.mu.reshape(self.mu.size, 1, 1, 1)
        _phi = self.phi.reshape(1, self.phi.size, 1, 1)
        _l = self.l.reshape(1, 1, self.l.size, 1)
        _epsilon_1 = epsilon_1.reshape(1, 1, 1, epsilon_1.size)
        # define integrating function
        _x = x_re_shell(_mu, self.target._R_line, _l)
        _mu_star = mu_star(_mu, self.target._R_line, _l)

        _cos_psi = cos_psi(_mu_s, _mu_star, _phi)
        _s = _epsilon_1 * self.target.epsilon_line * (1 - _cos_psi) / 2
        _integrand = (1 - _cos_psi) * np.power(_x, -2) * sigma(_s)

        prefactor_num = self.target.xi_line * self.target.parent_disk._L_disk
        prefactor_denum = (
            np.power(4 * np.pi, 2) * self.target.epsilon_line * ME * np.power(C, 3)
        )

        integral_mu = np.trapz(_integrand, self.mu, axis=0)
        integral_phi = np.trapz(integral_mu, self.phi, axis=0)
        integral = np.trapz(integral_phi, self.l, axis=0)

        return prefactor_num / prefactor_denum * integral

    def _opacity_ring_torus(self, nu):
        """opacity generated by a ring Dust Torus

        Parameters
        ----------
        nu : `~astropy.units.Quantity`
            array of frequencies, in Hz, to compute the sed, **note** these are 
            observed frequencies (observer frame).
        """
        # define the dimensionless energy
        epsilon_1_obs = H * nu.to("Hz").value / MEC2
        # transform to BH frame
        epsilon_1 = epsilon_1_obs * (1 + self.blob.z)
        # axis 0: phi
        # axis 1: l
        # axis 2: epsilon_1
        _mu_s = self.blob.mu_s
        _phi = self.phi.reshape(self.phi.size, 1, 1)
        _l = self.l.reshape(1, self.l.size, 1)
        _epsilon_1 = epsilon_1.reshape(1, 1, epsilon_1.size)
        _x = x_re_ring(self.target._R_dt, _l)
        _mu = _l / _x

        _cos_psi = cos_psi(_mu_s, _mu, _phi)
        _s = _epsilon_1 * self.target.epsilon_dt * (1 - _cos_psi) / 2
        _integrand = (1 - _cos_psi) * np.power(_x, -2) * sigma(_s)

        prefactor_num = self.target.xi_dt * self.target.parent_disk._L_disk
        prefactor_denum = (
            np.power(4 * np.pi, 2) * self.target.epsilon_dt * ME * np.power(C, 3)
        )

        integral_phi = np.trapz(_integrand, self.phi, axis=0)
        integral = np.trapz(integral_phi, self.l, axis=0)

        return prefactor_num / prefactor_denum * integral

    def tau(self, nu):
        """optical depth

        .. math::
            \\tau_{\\gamma \\gamma}(\\nu)

        Parameters
        ----------
        nu : `~astropy.units.Quantity`
            array of frequencies, in Hz, to compute the opacity, **note** these are 
            observed frequencies (observer frame).
        """
        if self.target.type == "SSDisk":
            return self._opacity_disk(nu)
        if self.target.type == "SphericalShellBLR":
            return self._opacity_shell_blr(nu)
        if self.target.type == "RingDustTorus":
            return self._opacity_ring_torus(nu)
