#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Exprs.ttypes
import Status.ttypes
import Types.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TCatalogObjectType:
  UNKNOWN = 0
  CATALOG = 1
  DATABASE = 2
  TABLE = 3
  VIEW = 4
  FUNCTION = 5
  DATA_SOURCE = 6
  PRINCIPAL = 7
  PRIVILEGE = 8
  HDFS_CACHE_POOL = 9
  AUTHZ_CACHE_INVALIDATION = 10

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "CATALOG",
    2: "DATABASE",
    3: "TABLE",
    4: "VIEW",
    5: "FUNCTION",
    6: "DATA_SOURCE",
    7: "PRINCIPAL",
    8: "PRIVILEGE",
    9: "HDFS_CACHE_POOL",
    10: "AUTHZ_CACHE_INVALIDATION",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "CATALOG": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "VIEW": 4,
    "FUNCTION": 5,
    "DATA_SOURCE": 6,
    "PRINCIPAL": 7,
    "PRIVILEGE": 8,
    "HDFS_CACHE_POOL": 9,
    "AUTHZ_CACHE_INVALIDATION": 10,
  }

class TTableType:
  HDFS_TABLE = 0
  HBASE_TABLE = 1
  VIEW = 2
  DATA_SOURCE_TABLE = 3
  KUDU_TABLE = 4

  _VALUES_TO_NAMES = {
    0: "HDFS_TABLE",
    1: "HBASE_TABLE",
    2: "VIEW",
    3: "DATA_SOURCE_TABLE",
    4: "KUDU_TABLE",
  }

  _NAMES_TO_VALUES = {
    "HDFS_TABLE": 0,
    "HBASE_TABLE": 1,
    "VIEW": 2,
    "DATA_SOURCE_TABLE": 3,
    "KUDU_TABLE": 4,
  }

class THdfsFileFormat:
  TEXT = 0
  RC_FILE = 1
  SEQUENCE_FILE = 2
  AVRO = 3
  PARQUET = 4
  KUDU = 5
  ORC = 6
  HUDI_PARQUET = 7

  _VALUES_TO_NAMES = {
    0: "TEXT",
    1: "RC_FILE",
    2: "SEQUENCE_FILE",
    3: "AVRO",
    4: "PARQUET",
    5: "KUDU",
    6: "ORC",
    7: "HUDI_PARQUET",
  }

  _NAMES_TO_VALUES = {
    "TEXT": 0,
    "RC_FILE": 1,
    "SEQUENCE_FILE": 2,
    "AVRO": 3,
    "PARQUET": 4,
    "KUDU": 5,
    "ORC": 6,
    "HUDI_PARQUET": 7,
  }

class THdfsCompression:
  NONE = 0
  DEFAULT = 1
  GZIP = 2
  DEFLATE = 3
  BZIP2 = 4
  SNAPPY = 5
  SNAPPY_BLOCKED = 6
  LZO = 7
  LZ4 = 8
  ZLIB = 9
  ZSTD = 10
  BROTLI = 11
  LZ4_BLOCKED = 12

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "DEFAULT",
    2: "GZIP",
    3: "DEFLATE",
    4: "BZIP2",
    5: "SNAPPY",
    6: "SNAPPY_BLOCKED",
    7: "LZO",
    8: "LZ4",
    9: "ZLIB",
    10: "ZSTD",
    11: "BROTLI",
    12: "LZ4_BLOCKED",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "DEFAULT": 1,
    "GZIP": 2,
    "DEFLATE": 3,
    "BZIP2": 4,
    "SNAPPY": 5,
    "SNAPPY_BLOCKED": 6,
    "LZO": 7,
    "LZ4": 8,
    "ZLIB": 9,
    "ZSTD": 10,
    "BROTLI": 11,
    "LZ4_BLOCKED": 12,
  }

class TColumnEncoding:
  AUTO = 0
  PLAIN = 1
  PREFIX = 2
  GROUP_VARINT = 3
  RLE = 4
  DICTIONARY = 5
  BIT_SHUFFLE = 6

  _VALUES_TO_NAMES = {
    0: "AUTO",
    1: "PLAIN",
    2: "PREFIX",
    3: "GROUP_VARINT",
    4: "RLE",
    5: "DICTIONARY",
    6: "BIT_SHUFFLE",
  }

  _NAMES_TO_VALUES = {
    "AUTO": 0,
    "PLAIN": 1,
    "PREFIX": 2,
    "GROUP_VARINT": 3,
    "RLE": 4,
    "DICTIONARY": 5,
    "BIT_SHUFFLE": 6,
  }

class THdfsSeqCompressionMode:
  RECORD = 0
  BLOCK = 1

  _VALUES_TO_NAMES = {
    0: "RECORD",
    1: "BLOCK",
  }

  _NAMES_TO_VALUES = {
    "RECORD": 0,
    "BLOCK": 1,
  }

class TTablePropertyType:
  TBL_PROPERTY = 0
  SERDE_PROPERTY = 1

  _VALUES_TO_NAMES = {
    0: "TBL_PROPERTY",
    1: "SERDE_PROPERTY",
  }

  _NAMES_TO_VALUES = {
    "TBL_PROPERTY": 0,
    "SERDE_PROPERTY": 1,
  }

class TAccessLevel:
  NONE = 0
  READ_WRITE = 1
  READ_ONLY = 2
  WRITE_ONLY = 3

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "READ_WRITE",
    2: "READ_ONLY",
    3: "WRITE_ONLY",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "READ_WRITE": 1,
    "READ_ONLY": 2,
    "WRITE_ONLY": 3,
  }

class TPrincipalType:
  ROLE = 0
  USER = 1
  GROUP = 2

  _VALUES_TO_NAMES = {
    0: "ROLE",
    1: "USER",
    2: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "ROLE": 0,
    "USER": 1,
    "GROUP": 2,
  }

class TPrivilegeScope:
  SERVER = 0
  URI = 1
  DATABASE = 2
  TABLE = 3
  COLUMN = 4

  _VALUES_TO_NAMES = {
    0: "SERVER",
    1: "URI",
    2: "DATABASE",
    3: "TABLE",
    4: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "SERVER": 0,
    "URI": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "COLUMN": 4,
  }

class TPrivilegeLevel:
  ALL = 0
  INSERT = 1
  SELECT = 2
  REFRESH = 3
  CREATE = 4
  ALTER = 5
  DROP = 6
  OWNER = 7

  _VALUES_TO_NAMES = {
    0: "ALL",
    1: "INSERT",
    2: "SELECT",
    3: "REFRESH",
    4: "CREATE",
    5: "ALTER",
    6: "DROP",
    7: "OWNER",
  }

  _NAMES_TO_VALUES = {
    "ALL": 0,
    "INSERT": 1,
    "SELECT": 2,
    "REFRESH": 3,
    "CREATE": 4,
    "ALTER": 5,
    "DROP": 6,
    "OWNER": 7,
  }


class TCompressionCodec:
  """
  Attributes:
   - codec
   - compression_level
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'codec', None, None, ), # 1
    (2, TType.I32, 'compression_level', None, None, ), # 2
  )

  def __init__(self, codec=None, compression_level=None,):
    self.codec = codec
    self.compression_level = compression_level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.codec = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.compression_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCompressionCodec')
    if self.codec is not None:
      oprot.writeFieldBegin('codec', TType.I32, 1)
      oprot.writeI32(self.codec)
      oprot.writeFieldEnd()
    if self.compression_level is not None:
      oprot.writeFieldBegin('compression_level', TType.I32, 2)
      oprot.writeI32(self.compression_level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.codec is None:
      raise TProtocol.TProtocolException(message='Required field codec is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.codec)
    value = (value * 31) ^ hash(self.compression_level)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartitionKeyValue:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartitionKeyValue')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableName:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableName')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableStats:
  """
  Attributes:
   - num_rows
   - total_file_bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'num_rows', None, None, ), # 1
    (2, TType.I64, 'total_file_bytes', None, None, ), # 2
  )

  def __init__(self, num_rows=None, total_file_bytes=None,):
    self.num_rows = num_rows
    self.total_file_bytes = total_file_bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.num_rows = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.total_file_bytes = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableStats')
    if self.num_rows is not None:
      oprot.writeFieldBegin('num_rows', TType.I64, 1)
      oprot.writeI64(self.num_rows)
      oprot.writeFieldEnd()
    if self.total_file_bytes is not None:
      oprot.writeFieldBegin('total_file_bytes', TType.I64, 2)
      oprot.writeI64(self.total_file_bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_rows is None:
      raise TProtocol.TProtocolException(message='Required field num_rows is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_rows)
    value = (value * 31) ^ hash(self.total_file_bytes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnStats:
  """
  Attributes:
   - avg_size
   - max_size
   - num_distinct_values
   - num_nulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'avg_size', None, None, ), # 1
    (2, TType.I64, 'max_size', None, None, ), # 2
    (3, TType.I64, 'num_distinct_values', None, None, ), # 3
    (4, TType.I64, 'num_nulls', None, None, ), # 4
  )

  def __init__(self, avg_size=None, max_size=None, num_distinct_values=None, num_nulls=None,):
    self.avg_size = avg_size
    self.max_size = max_size
    self.num_distinct_values = num_distinct_values
    self.num_nulls = num_nulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.avg_size = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max_size = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.num_distinct_values = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.num_nulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnStats')
    if self.avg_size is not None:
      oprot.writeFieldBegin('avg_size', TType.DOUBLE, 1)
      oprot.writeDouble(self.avg_size)
      oprot.writeFieldEnd()
    if self.max_size is not None:
      oprot.writeFieldBegin('max_size', TType.I64, 2)
      oprot.writeI64(self.max_size)
      oprot.writeFieldEnd()
    if self.num_distinct_values is not None:
      oprot.writeFieldBegin('num_distinct_values', TType.I64, 3)
      oprot.writeI64(self.num_distinct_values)
      oprot.writeFieldEnd()
    if self.num_nulls is not None:
      oprot.writeFieldBegin('num_nulls', TType.I64, 4)
      oprot.writeI64(self.num_nulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.avg_size is None:
      raise TProtocol.TProtocolException(message='Required field avg_size is unset!')
    if self.max_size is None:
      raise TProtocol.TProtocolException(message='Required field max_size is unset!')
    if self.num_distinct_values is None:
      raise TProtocol.TProtocolException(message='Required field num_distinct_values is unset!')
    if self.num_nulls is None:
      raise TProtocol.TProtocolException(message='Required field num_nulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.avg_size)
    value = (value * 31) ^ hash(self.max_size)
    value = (value * 31) ^ hash(self.num_distinct_values)
    value = (value * 31) ^ hash(self.num_nulls)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIntermediateColumnStats:
  """
  Attributes:
   - intermediate_ndv
   - is_ndv_encoded
   - num_nulls
   - max_width
   - avg_width
   - num_rows
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'intermediate_ndv', None, None, ), # 1
    (2, TType.BOOL, 'is_ndv_encoded', None, None, ), # 2
    (3, TType.I64, 'num_nulls', None, None, ), # 3
    (4, TType.I32, 'max_width', None, None, ), # 4
    (5, TType.DOUBLE, 'avg_width', None, None, ), # 5
    (6, TType.I64, 'num_rows', None, None, ), # 6
  )

  def __init__(self, intermediate_ndv=None, is_ndv_encoded=None, num_nulls=None, max_width=None, avg_width=None, num_rows=None,):
    self.intermediate_ndv = intermediate_ndv
    self.is_ndv_encoded = is_ndv_encoded
    self.num_nulls = num_nulls
    self.max_width = max_width
    self.avg_width = avg_width
    self.num_rows = num_rows

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.intermediate_ndv = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_ndv_encoded = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.num_nulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.max_width = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.avg_width = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.num_rows = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIntermediateColumnStats')
    if self.intermediate_ndv is not None:
      oprot.writeFieldBegin('intermediate_ndv', TType.STRING, 1)
      oprot.writeString(self.intermediate_ndv)
      oprot.writeFieldEnd()
    if self.is_ndv_encoded is not None:
      oprot.writeFieldBegin('is_ndv_encoded', TType.BOOL, 2)
      oprot.writeBool(self.is_ndv_encoded)
      oprot.writeFieldEnd()
    if self.num_nulls is not None:
      oprot.writeFieldBegin('num_nulls', TType.I64, 3)
      oprot.writeI64(self.num_nulls)
      oprot.writeFieldEnd()
    if self.max_width is not None:
      oprot.writeFieldBegin('max_width', TType.I32, 4)
      oprot.writeI32(self.max_width)
      oprot.writeFieldEnd()
    if self.avg_width is not None:
      oprot.writeFieldBegin('avg_width', TType.DOUBLE, 5)
      oprot.writeDouble(self.avg_width)
      oprot.writeFieldEnd()
    if self.num_rows is not None:
      oprot.writeFieldBegin('num_rows', TType.I64, 6)
      oprot.writeI64(self.num_rows)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intermediate_ndv)
    value = (value * 31) ^ hash(self.is_ndv_encoded)
    value = (value * 31) ^ hash(self.num_nulls)
    value = (value * 31) ^ hash(self.max_width)
    value = (value * 31) ^ hash(self.avg_width)
    value = (value * 31) ^ hash(self.num_rows)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartitionStats:
  """
  Attributes:
   - stats
   - intermediate_col_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats', (TTableStats, TTableStats.thrift_spec), None, ), # 1
    (2, TType.MAP, 'intermediate_col_stats', (TType.STRING,None,TType.STRUCT,(TIntermediateColumnStats, TIntermediateColumnStats.thrift_spec)), None, ), # 2
  )

  def __init__(self, stats=None, intermediate_col_stats=None,):
    self.stats = stats
    self.intermediate_col_stats = intermediate_col_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats = TTableStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.intermediate_col_stats = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString()
            _val6 = TIntermediateColumnStats()
            _val6.read(iprot)
            self.intermediate_col_stats[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartitionStats')
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 1)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.intermediate_col_stats is not None:
      oprot.writeFieldBegin('intermediate_col_stats', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.intermediate_col_stats))
      for kiter7,viter8 in self.intermediate_col_stats.items():
        oprot.writeString(kiter7)
        viter8.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stats is None:
      raise TProtocol.TProtocolException(message='Required field stats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stats)
    value = (value * 31) ^ hash(self.intermediate_col_stats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumn:
  """
  Attributes:
   - columnName
   - columnType
   - comment
   - col_stats
   - position
   - is_hbase_column
   - column_family
   - column_qualifier
   - is_binary
   - is_kudu_column
   - is_key
   - is_nullable
   - encoding
   - compression
   - default_value
   - block_size
   - kudu_column_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'columnName', None, None, ), # 1
    (2, TType.STRUCT, 'columnType', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
    (4, TType.STRUCT, 'col_stats', (TColumnStats, TColumnStats.thrift_spec), None, ), # 4
    (5, TType.I32, 'position', None, None, ), # 5
    (6, TType.BOOL, 'is_hbase_column', None, None, ), # 6
    (7, TType.STRING, 'column_family', None, None, ), # 7
    (8, TType.STRING, 'column_qualifier', None, None, ), # 8
    (9, TType.BOOL, 'is_binary', None, None, ), # 9
    (10, TType.BOOL, 'is_kudu_column', None, None, ), # 10
    (11, TType.BOOL, 'is_key', None, None, ), # 11
    (12, TType.BOOL, 'is_nullable', None, None, ), # 12
    (13, TType.I32, 'encoding', None, None, ), # 13
    (14, TType.I32, 'compression', None, None, ), # 14
    (15, TType.STRUCT, 'default_value', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 15
    (16, TType.I32, 'block_size', None, None, ), # 16
    (17, TType.STRING, 'kudu_column_name', None, None, ), # 17
  )

  def __init__(self, columnName=None, columnType=None, comment=None, col_stats=None, position=None, is_hbase_column=None, column_family=None, column_qualifier=None, is_binary=None, is_kudu_column=None, is_key=None, is_nullable=None, encoding=None, compression=None, default_value=None, block_size=None, kudu_column_name=None,):
    self.columnName = columnName
    self.columnType = columnType
    self.comment = comment
    self.col_stats = col_stats
    self.position = position
    self.is_hbase_column = is_hbase_column
    self.column_family = column_family
    self.column_qualifier = column_qualifier
    self.is_binary = is_binary
    self.is_kudu_column = is_kudu_column
    self.is_key = is_key
    self.is_nullable = is_nullable
    self.encoding = encoding
    self.compression = compression
    self.default_value = default_value
    self.block_size = block_size
    self.kudu_column_name = kudu_column_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.columnName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.columnType = Types.ttypes.TColumnType()
          self.columnType.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.col_stats = TColumnStats()
          self.col_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.position = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_hbase_column = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.column_family = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.column_qualifier = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.is_binary = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.is_kudu_column = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.is_key = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.is_nullable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.encoding = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.compression = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.default_value = Exprs.ttypes.TExpr()
          self.default_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          self.block_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.kudu_column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumn')
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 1)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    if self.columnType is not None:
      oprot.writeFieldBegin('columnType', TType.STRUCT, 2)
      self.columnType.write(oprot)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.col_stats is not None:
      oprot.writeFieldBegin('col_stats', TType.STRUCT, 4)
      self.col_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 5)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.is_hbase_column is not None:
      oprot.writeFieldBegin('is_hbase_column', TType.BOOL, 6)
      oprot.writeBool(self.is_hbase_column)
      oprot.writeFieldEnd()
    if self.column_family is not None:
      oprot.writeFieldBegin('column_family', TType.STRING, 7)
      oprot.writeString(self.column_family)
      oprot.writeFieldEnd()
    if self.column_qualifier is not None:
      oprot.writeFieldBegin('column_qualifier', TType.STRING, 8)
      oprot.writeString(self.column_qualifier)
      oprot.writeFieldEnd()
    if self.is_binary is not None:
      oprot.writeFieldBegin('is_binary', TType.BOOL, 9)
      oprot.writeBool(self.is_binary)
      oprot.writeFieldEnd()
    if self.is_kudu_column is not None:
      oprot.writeFieldBegin('is_kudu_column', TType.BOOL, 10)
      oprot.writeBool(self.is_kudu_column)
      oprot.writeFieldEnd()
    if self.is_key is not None:
      oprot.writeFieldBegin('is_key', TType.BOOL, 11)
      oprot.writeBool(self.is_key)
      oprot.writeFieldEnd()
    if self.is_nullable is not None:
      oprot.writeFieldBegin('is_nullable', TType.BOOL, 12)
      oprot.writeBool(self.is_nullable)
      oprot.writeFieldEnd()
    if self.encoding is not None:
      oprot.writeFieldBegin('encoding', TType.I32, 13)
      oprot.writeI32(self.encoding)
      oprot.writeFieldEnd()
    if self.compression is not None:
      oprot.writeFieldBegin('compression', TType.I32, 14)
      oprot.writeI32(self.compression)
      oprot.writeFieldEnd()
    if self.default_value is not None:
      oprot.writeFieldBegin('default_value', TType.STRUCT, 15)
      self.default_value.write(oprot)
      oprot.writeFieldEnd()
    if self.block_size is not None:
      oprot.writeFieldBegin('block_size', TType.I32, 16)
      oprot.writeI32(self.block_size)
      oprot.writeFieldEnd()
    if self.kudu_column_name is not None:
      oprot.writeFieldBegin('kudu_column_name', TType.STRING, 17)
      oprot.writeString(self.kudu_column_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnName is None:
      raise TProtocol.TProtocolException(message='Required field columnName is unset!')
    if self.columnType is None:
      raise TProtocol.TProtocolException(message='Required field columnType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.columnName)
    value = (value * 31) ^ hash(self.columnType)
    value = (value * 31) ^ hash(self.comment)
    value = (value * 31) ^ hash(self.col_stats)
    value = (value * 31) ^ hash(self.position)
    value = (value * 31) ^ hash(self.is_hbase_column)
    value = (value * 31) ^ hash(self.column_family)
    value = (value * 31) ^ hash(self.column_qualifier)
    value = (value * 31) ^ hash(self.is_binary)
    value = (value * 31) ^ hash(self.is_kudu_column)
    value = (value * 31) ^ hash(self.is_key)
    value = (value * 31) ^ hash(self.is_nullable)
    value = (value * 31) ^ hash(self.encoding)
    value = (value * 31) ^ hash(self.compression)
    value = (value * 31) ^ hash(self.default_value)
    value = (value * 31) ^ hash(self.block_size)
    value = (value * 31) ^ hash(self.kudu_column_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsFileDesc:
  """
  Attributes:
   - file_desc_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file_desc_data', None, None, ), # 1
  )

  def __init__(self, file_desc_data=None,):
    self.file_desc_data = file_desc_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file_desc_data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileDesc')
    if self.file_desc_data is not None:
      oprot.writeFieldBegin('file_desc_data', TType.STRING, 1)
      oprot.writeString(self.file_desc_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_desc_data is None:
      raise TProtocol.TProtocolException(message='Required field file_desc_data is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.file_desc_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsPartitionLocation:
  """
  Attributes:
   - prefix_index
   - suffix
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'prefix_index', None, -1, ), # 1
    (2, TType.STRING, 'suffix', None, None, ), # 2
  )

  def __init__(self, prefix_index=thrift_spec[1][4], suffix=None,):
    self.prefix_index = prefix_index
    self.suffix = suffix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.prefix_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.suffix = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsPartitionLocation')
    if self.prefix_index is not None:
      oprot.writeFieldBegin('prefix_index', TType.I32, 1)
      oprot.writeI32(self.prefix_index)
      oprot.writeFieldEnd()
    if self.suffix is not None:
      oprot.writeFieldBegin('suffix', TType.STRING, 2)
      oprot.writeString(self.suffix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.prefix_index is None:
      raise TProtocol.TProtocolException(message='Required field prefix_index is unset!')
    if self.suffix is None:
      raise TProtocol.TProtocolException(message='Required field suffix is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.prefix_index)
    value = (value * 31) ^ hash(self.suffix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsPartition:
  """
  Attributes:
   - lineDelim
   - fieldDelim
   - collectionDelim
   - mapKeyDelim
   - escapeChar
   - fileFormat
   - partitionKeyExprs
   - blockSize
   - location
   - id
   - file_desc
   - access_level
   - stats
   - is_marked_cached
   - hms_parameters
   - num_blocks
   - total_file_size_bytes
   - partition_stats
   - has_incremental_stats
   - write_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'lineDelim', None, None, ), # 1
    (2, TType.BYTE, 'fieldDelim', None, None, ), # 2
    (3, TType.BYTE, 'collectionDelim', None, None, ), # 3
    (4, TType.BYTE, 'mapKeyDelim', None, None, ), # 4
    (5, TType.BYTE, 'escapeChar', None, None, ), # 5
    (6, TType.I32, 'fileFormat', None, None, ), # 6
    (7, TType.LIST, 'partitionKeyExprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.I32, 'blockSize', None, None, ), # 8
    (9, TType.LIST, 'file_desc', (TType.STRUCT,(THdfsFileDesc, THdfsFileDesc.thrift_spec)), None, ), # 9
    (10, TType.STRUCT, 'location', (THdfsPartitionLocation, THdfsPartitionLocation.thrift_spec), None, ), # 10
    (11, TType.I32, 'access_level', None, None, ), # 11
    (12, TType.STRUCT, 'stats', (TTableStats, TTableStats.thrift_spec), None, ), # 12
    (13, TType.BOOL, 'is_marked_cached', None, None, ), # 13
    (14, TType.I64, 'id', None, None, ), # 14
    (15, TType.MAP, 'hms_parameters', (TType.STRING,None,TType.STRING,None), None, ), # 15
    (16, TType.I64, 'num_blocks', None, None, ), # 16
    (17, TType.I64, 'total_file_size_bytes', None, None, ), # 17
    (18, TType.STRING, 'partition_stats', None, None, ), # 18
    (19, TType.BOOL, 'has_incremental_stats', None, None, ), # 19
    (20, TType.I64, 'write_id', None, None, ), # 20
  )

  def __init__(self, lineDelim=None, fieldDelim=None, collectionDelim=None, mapKeyDelim=None, escapeChar=None, fileFormat=None, partitionKeyExprs=None, blockSize=None, location=None, id=None, file_desc=None, access_level=None, stats=None, is_marked_cached=None, hms_parameters=None, num_blocks=None, total_file_size_bytes=None, partition_stats=None, has_incremental_stats=None, write_id=None,):
    self.lineDelim = lineDelim
    self.fieldDelim = fieldDelim
    self.collectionDelim = collectionDelim
    self.mapKeyDelim = mapKeyDelim
    self.escapeChar = escapeChar
    self.fileFormat = fileFormat
    self.partitionKeyExprs = partitionKeyExprs
    self.blockSize = blockSize
    self.location = location
    self.id = id
    self.file_desc = file_desc
    self.access_level = access_level
    self.stats = stats
    self.is_marked_cached = is_marked_cached
    self.hms_parameters = hms_parameters
    self.num_blocks = num_blocks
    self.total_file_size_bytes = total_file_size_bytes
    self.partition_stats = partition_stats
    self.has_incremental_stats = has_incremental_stats
    self.write_id = write_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.lineDelim = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.fieldDelim = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.collectionDelim = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.mapKeyDelim = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.escapeChar = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.fileFormat = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.partitionKeyExprs = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = Exprs.ttypes.TExpr()
            _elem14.read(iprot)
            self.partitionKeyExprs.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.blockSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.location = THdfsPartitionLocation()
          self.location.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.file_desc = []
          (_etype18, _size15) = iprot.readListBegin()
          for _i19 in xrange(_size15):
            _elem20 = THdfsFileDesc()
            _elem20.read(iprot)
            self.file_desc.append(_elem20)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.access_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.stats = TTableStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.is_marked_cached = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.MAP:
          self.hms_parameters = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString()
            _val27 = iprot.readString()
            self.hms_parameters[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.num_blocks = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.total_file_size_bytes = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.partition_stats = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.has_incremental_stats = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I64:
          self.write_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsPartition')
    if self.lineDelim is not None:
      oprot.writeFieldBegin('lineDelim', TType.BYTE, 1)
      oprot.writeByte(self.lineDelim)
      oprot.writeFieldEnd()
    if self.fieldDelim is not None:
      oprot.writeFieldBegin('fieldDelim', TType.BYTE, 2)
      oprot.writeByte(self.fieldDelim)
      oprot.writeFieldEnd()
    if self.collectionDelim is not None:
      oprot.writeFieldBegin('collectionDelim', TType.BYTE, 3)
      oprot.writeByte(self.collectionDelim)
      oprot.writeFieldEnd()
    if self.mapKeyDelim is not None:
      oprot.writeFieldBegin('mapKeyDelim', TType.BYTE, 4)
      oprot.writeByte(self.mapKeyDelim)
      oprot.writeFieldEnd()
    if self.escapeChar is not None:
      oprot.writeFieldBegin('escapeChar', TType.BYTE, 5)
      oprot.writeByte(self.escapeChar)
      oprot.writeFieldEnd()
    if self.fileFormat is not None:
      oprot.writeFieldBegin('fileFormat', TType.I32, 6)
      oprot.writeI32(self.fileFormat)
      oprot.writeFieldEnd()
    if self.partitionKeyExprs is not None:
      oprot.writeFieldBegin('partitionKeyExprs', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeyExprs))
      for iter28 in self.partitionKeyExprs:
        iter28.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.blockSize is not None:
      oprot.writeFieldBegin('blockSize', TType.I32, 8)
      oprot.writeI32(self.blockSize)
      oprot.writeFieldEnd()
    if self.file_desc is not None:
      oprot.writeFieldBegin('file_desc', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.file_desc))
      for iter29 in self.file_desc:
        iter29.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRUCT, 10)
      self.location.write(oprot)
      oprot.writeFieldEnd()
    if self.access_level is not None:
      oprot.writeFieldBegin('access_level', TType.I32, 11)
      oprot.writeI32(self.access_level)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 12)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.is_marked_cached is not None:
      oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 13)
      oprot.writeBool(self.is_marked_cached)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 14)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.hms_parameters is not None:
      oprot.writeFieldBegin('hms_parameters', TType.MAP, 15)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.hms_parameters))
      for kiter30,viter31 in self.hms_parameters.items():
        oprot.writeString(kiter30)
        oprot.writeString(viter31)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.num_blocks is not None:
      oprot.writeFieldBegin('num_blocks', TType.I64, 16)
      oprot.writeI64(self.num_blocks)
      oprot.writeFieldEnd()
    if self.total_file_size_bytes is not None:
      oprot.writeFieldBegin('total_file_size_bytes', TType.I64, 17)
      oprot.writeI64(self.total_file_size_bytes)
      oprot.writeFieldEnd()
    if self.partition_stats is not None:
      oprot.writeFieldBegin('partition_stats', TType.STRING, 18)
      oprot.writeString(self.partition_stats)
      oprot.writeFieldEnd()
    if self.has_incremental_stats is not None:
      oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 19)
      oprot.writeBool(self.has_incremental_stats)
      oprot.writeFieldEnd()
    if self.write_id is not None:
      oprot.writeFieldBegin('write_id', TType.I64, 20)
      oprot.writeI64(self.write_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lineDelim is None:
      raise TProtocol.TProtocolException(message='Required field lineDelim is unset!')
    if self.fieldDelim is None:
      raise TProtocol.TProtocolException(message='Required field fieldDelim is unset!')
    if self.collectionDelim is None:
      raise TProtocol.TProtocolException(message='Required field collectionDelim is unset!')
    if self.mapKeyDelim is None:
      raise TProtocol.TProtocolException(message='Required field mapKeyDelim is unset!')
    if self.escapeChar is None:
      raise TProtocol.TProtocolException(message='Required field escapeChar is unset!')
    if self.fileFormat is None:
      raise TProtocol.TProtocolException(message='Required field fileFormat is unset!')
    if self.blockSize is None:
      raise TProtocol.TProtocolException(message='Required field blockSize is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lineDelim)
    value = (value * 31) ^ hash(self.fieldDelim)
    value = (value * 31) ^ hash(self.collectionDelim)
    value = (value * 31) ^ hash(self.mapKeyDelim)
    value = (value * 31) ^ hash(self.escapeChar)
    value = (value * 31) ^ hash(self.fileFormat)
    value = (value * 31) ^ hash(self.partitionKeyExprs)
    value = (value * 31) ^ hash(self.blockSize)
    value = (value * 31) ^ hash(self.location)
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.file_desc)
    value = (value * 31) ^ hash(self.access_level)
    value = (value * 31) ^ hash(self.stats)
    value = (value * 31) ^ hash(self.is_marked_cached)
    value = (value * 31) ^ hash(self.hms_parameters)
    value = (value * 31) ^ hash(self.num_blocks)
    value = (value * 31) ^ hash(self.total_file_size_bytes)
    value = (value * 31) ^ hash(self.partition_stats)
    value = (value * 31) ^ hash(self.has_incremental_stats)
    value = (value * 31) ^ hash(self.write_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsTable:
  """
  Attributes:
   - hdfsBaseDir
   - colNames
   - nullPartitionKeyValue
   - nullColumnValue
   - avroSchema
   - partitions
   - prototype_partition
   - partition_prefixes
   - network_addresses
   - sql_constraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hdfsBaseDir', None, None, ), # 1
    (2, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'nullPartitionKeyValue', None, None, ), # 3
    (4, TType.MAP, 'partitions', (TType.I64,None,TType.STRUCT,(THdfsPartition, THdfsPartition.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'nullColumnValue', None, None, ), # 5
    (6, TType.STRING, 'avroSchema', None, None, ), # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT,(Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec)), None, ), # 7
    None, # 8
    (9, TType.LIST, 'partition_prefixes', (TType.STRING,None), None, ), # 9
    (10, TType.STRUCT, 'prototype_partition', (THdfsPartition, THdfsPartition.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'sql_constraints', (SqlConstraints.ttypes.TSqlConstraints, SqlConstraints.ttypes.TSqlConstraints.thrift_spec), None, ), # 11
  )

  def __init__(self, hdfsBaseDir=None, colNames=None, nullPartitionKeyValue=None, nullColumnValue=None, avroSchema=None, partitions=None, prototype_partition=None, partition_prefixes=None, network_addresses=None, sql_constraints=None,):
    self.hdfsBaseDir = hdfsBaseDir
    self.colNames = colNames
    self.nullPartitionKeyValue = nullPartitionKeyValue
    self.nullColumnValue = nullColumnValue
    self.avroSchema = avroSchema
    self.partitions = partitions
    self.prototype_partition = prototype_partition
    self.partition_prefixes = partition_prefixes
    self.network_addresses = network_addresses
    self.sql_constraints = sql_constraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hdfsBaseDir = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = iprot.readString()
            self.colNames.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nullPartitionKeyValue = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.nullColumnValue = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.avroSchema = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.partitions = {}
          (_ktype39, _vtype40, _size38 ) = iprot.readMapBegin()
          for _i42 in xrange(_size38):
            _key43 = iprot.readI64()
            _val44 = THdfsPartition()
            _val44.read(iprot)
            self.partitions[_key43] = _val44
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.prototype_partition = THdfsPartition()
          self.prototype_partition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.partition_prefixes = []
          (_etype48, _size45) = iprot.readListBegin()
          for _i49 in xrange(_size45):
            _elem50 = iprot.readString()
            self.partition_prefixes.append(_elem50)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.network_addresses = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = Types.ttypes.TNetworkAddress()
            _elem56.read(iprot)
            self.network_addresses.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
          self.sql_constraints.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsTable')
    if self.hdfsBaseDir is not None:
      oprot.writeFieldBegin('hdfsBaseDir', TType.STRING, 1)
      oprot.writeString(self.hdfsBaseDir)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter57 in self.colNames:
        oprot.writeString(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullPartitionKeyValue is not None:
      oprot.writeFieldBegin('nullPartitionKeyValue', TType.STRING, 3)
      oprot.writeString(self.nullPartitionKeyValue)
      oprot.writeFieldEnd()
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.MAP, 4)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.partitions))
      for kiter58,viter59 in self.partitions.items():
        oprot.writeI64(kiter58)
        viter59.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.nullColumnValue is not None:
      oprot.writeFieldBegin('nullColumnValue', TType.STRING, 5)
      oprot.writeString(self.nullColumnValue)
      oprot.writeFieldEnd()
    if self.avroSchema is not None:
      oprot.writeFieldBegin('avroSchema', TType.STRING, 6)
      oprot.writeString(self.avroSchema)
      oprot.writeFieldEnd()
    if self.network_addresses is not None:
      oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
      for iter60 in self.network_addresses:
        iter60.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_prefixes is not None:
      oprot.writeFieldBegin('partition_prefixes', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.partition_prefixes))
      for iter61 in self.partition_prefixes:
        oprot.writeString(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prototype_partition is not None:
      oprot.writeFieldBegin('prototype_partition', TType.STRUCT, 10)
      self.prototype_partition.write(oprot)
      oprot.writeFieldEnd()
    if self.sql_constraints is not None:
      oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 11)
      self.sql_constraints.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hdfsBaseDir is None:
      raise TProtocol.TProtocolException(message='Required field hdfsBaseDir is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    if self.nullPartitionKeyValue is None:
      raise TProtocol.TProtocolException(message='Required field nullPartitionKeyValue is unset!')
    if self.nullColumnValue is None:
      raise TProtocol.TProtocolException(message='Required field nullColumnValue is unset!')
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    if self.prototype_partition is None:
      raise TProtocol.TProtocolException(message='Required field prototype_partition is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hdfsBaseDir)
    value = (value * 31) ^ hash(self.colNames)
    value = (value * 31) ^ hash(self.nullPartitionKeyValue)
    value = (value * 31) ^ hash(self.nullColumnValue)
    value = (value * 31) ^ hash(self.avroSchema)
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.prototype_partition)
    value = (value * 31) ^ hash(self.partition_prefixes)
    value = (value * 31) ^ hash(self.network_addresses)
    value = (value * 31) ^ hash(self.sql_constraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseTable:
  """
  Attributes:
   - tableName
   - families
   - qualifiers
   - binary_encoded
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.LIST, 'families', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'qualifiers', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'binary_encoded', (TType.BOOL,None), None, ), # 4
  )

  def __init__(self, tableName=None, families=None, qualifiers=None, binary_encoded=None,):
    self.tableName = tableName
    self.families = families
    self.qualifiers = qualifiers
    self.binary_encoded = binary_encoded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.families = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString()
            self.families.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.qualifiers = []
          (_etype71, _size68) = iprot.readListBegin()
          for _i72 in xrange(_size68):
            _elem73 = iprot.readString()
            self.qualifiers.append(_elem73)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.binary_encoded = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = iprot.readBool()
            self.binary_encoded.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseTable')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.families is not None:
      oprot.writeFieldBegin('families', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.families))
      for iter80 in self.families:
        oprot.writeString(iter80)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.qualifiers is not None:
      oprot.writeFieldBegin('qualifiers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.qualifiers))
      for iter81 in self.qualifiers:
        oprot.writeString(iter81)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binary_encoded is not None:
      oprot.writeFieldBegin('binary_encoded', TType.LIST, 4)
      oprot.writeListBegin(TType.BOOL, len(self.binary_encoded))
      for iter82 in self.binary_encoded:
        oprot.writeBool(iter82)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    if self.families is None:
      raise TProtocol.TProtocolException(message='Required field families is unset!')
    if self.qualifiers is None:
      raise TProtocol.TProtocolException(message='Required field qualifiers is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.families)
    value = (value * 31) ^ hash(self.qualifiers)
    value = (value * 31) ^ hash(self.binary_encoded)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSource:
  """
  Attributes:
   - name
   - hdfs_location
   - class_name
   - api_version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'hdfs_location', None, None, ), # 2
    (3, TType.STRING, 'class_name', None, None, ), # 3
    (4, TType.STRING, 'api_version', None, None, ), # 4
  )

  def __init__(self, name=None, hdfs_location=None, class_name=None, api_version=None,):
    self.name = name
    self.hdfs_location = hdfs_location
    self.class_name = class_name
    self.api_version = api_version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfs_location = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.class_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.api_version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSource')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.hdfs_location is not None:
      oprot.writeFieldBegin('hdfs_location', TType.STRING, 2)
      oprot.writeString(self.hdfs_location)
      oprot.writeFieldEnd()
    if self.class_name is not None:
      oprot.writeFieldBegin('class_name', TType.STRING, 3)
      oprot.writeString(self.class_name)
      oprot.writeFieldEnd()
    if self.api_version is not None:
      oprot.writeFieldBegin('api_version', TType.STRING, 4)
      oprot.writeString(self.api_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.hdfs_location is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_location is unset!')
    if self.class_name is None:
      raise TProtocol.TProtocolException(message='Required field class_name is unset!')
    if self.api_version is None:
      raise TProtocol.TProtocolException(message='Required field api_version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.hdfs_location)
    value = (value * 31) ^ hash(self.class_name)
    value = (value * 31) ^ hash(self.api_version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSourceTable:
  """
  Attributes:
   - data_source
   - init_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data_source', (TDataSource, TDataSource.thrift_spec), None, ), # 1
    (2, TType.STRING, 'init_string', None, None, ), # 2
  )

  def __init__(self, data_source=None, init_string=None,):
    self.data_source = data_source
    self.init_string = init_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data_source = TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.init_string = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSourceTable')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.init_string is not None:
      oprot.writeFieldBegin('init_string', TType.STRING, 2)
      oprot.writeString(self.init_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    if self.init_string is None:
      raise TProtocol.TProtocolException(message='Required field init_string is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.data_source)
    value = (value * 31) ^ hash(self.init_string)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduPartitionByHashParam:
  """
  Attributes:
   - columns
   - num_partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'num_partitions', None, None, ), # 2
  )

  def __init__(self, columns=None, num_partitions=None,):
    self.columns = columns
    self.num_partitions = num_partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readString()
            self.columns.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.num_partitions = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduPartitionByHashParam')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.columns))
      for iter89 in self.columns:
        oprot.writeString(iter89)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.num_partitions is not None:
      oprot.writeFieldBegin('num_partitions', TType.I32, 2)
      oprot.writeI32(self.num_partitions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.num_partitions is None:
      raise TProtocol.TProtocolException(message='Required field num_partitions is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.num_partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRangePartition:
  """
  Attributes:
   - lower_bound_values
   - is_lower_bound_inclusive
   - upper_bound_values
   - is_upper_bound_inclusive
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lower_bound_values', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'is_lower_bound_inclusive', None, None, ), # 2
    (3, TType.LIST, 'upper_bound_values', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'is_upper_bound_inclusive', None, None, ), # 4
  )

  def __init__(self, lower_bound_values=None, is_lower_bound_inclusive=None, upper_bound_values=None, is_upper_bound_inclusive=None,):
    self.lower_bound_values = lower_bound_values
    self.is_lower_bound_inclusive = is_lower_bound_inclusive
    self.upper_bound_values = upper_bound_values
    self.is_upper_bound_inclusive = is_upper_bound_inclusive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lower_bound_values = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = Exprs.ttypes.TExpr()
            _elem95.read(iprot)
            self.lower_bound_values.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_lower_bound_inclusive = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.upper_bound_values = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = Exprs.ttypes.TExpr()
            _elem101.read(iprot)
            self.upper_bound_values.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_upper_bound_inclusive = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRangePartition')
    if self.lower_bound_values is not None:
      oprot.writeFieldBegin('lower_bound_values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.lower_bound_values))
      for iter102 in self.lower_bound_values:
        iter102.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_lower_bound_inclusive is not None:
      oprot.writeFieldBegin('is_lower_bound_inclusive', TType.BOOL, 2)
      oprot.writeBool(self.is_lower_bound_inclusive)
      oprot.writeFieldEnd()
    if self.upper_bound_values is not None:
      oprot.writeFieldBegin('upper_bound_values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.upper_bound_values))
      for iter103 in self.upper_bound_values:
        iter103.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_upper_bound_inclusive is not None:
      oprot.writeFieldBegin('is_upper_bound_inclusive', TType.BOOL, 4)
      oprot.writeBool(self.is_upper_bound_inclusive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lower_bound_values)
    value = (value * 31) ^ hash(self.is_lower_bound_inclusive)
    value = (value * 31) ^ hash(self.upper_bound_values)
    value = (value * 31) ^ hash(self.is_upper_bound_inclusive)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduPartitionByRangeParam:
  """
  Attributes:
   - columns
   - range_partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'range_partitions', (TType.STRUCT,(TRangePartition, TRangePartition.thrift_spec)), None, ), # 2
  )

  def __init__(self, columns=None, range_partitions=None,):
    self.columns = columns
    self.range_partitions = range_partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype107, _size104) = iprot.readListBegin()
          for _i108 in xrange(_size104):
            _elem109 = iprot.readString()
            self.columns.append(_elem109)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.range_partitions = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = TRangePartition()
            _elem115.read(iprot)
            self.range_partitions.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduPartitionByRangeParam')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.columns))
      for iter116 in self.columns:
        oprot.writeString(iter116)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.range_partitions is not None:
      oprot.writeFieldBegin('range_partitions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.range_partitions))
      for iter117 in self.range_partitions:
        iter117.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.range_partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduPartitionParam:
  """
  Attributes:
   - by_hash_param
   - by_range_param
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'by_hash_param', (TKuduPartitionByHashParam, TKuduPartitionByHashParam.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'by_range_param', (TKuduPartitionByRangeParam, TKuduPartitionByRangeParam.thrift_spec), None, ), # 2
  )

  def __init__(self, by_hash_param=None, by_range_param=None,):
    self.by_hash_param = by_hash_param
    self.by_range_param = by_range_param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.by_hash_param = TKuduPartitionByHashParam()
          self.by_hash_param.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.by_range_param = TKuduPartitionByRangeParam()
          self.by_range_param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduPartitionParam')
    if self.by_hash_param is not None:
      oprot.writeFieldBegin('by_hash_param', TType.STRUCT, 1)
      self.by_hash_param.write(oprot)
      oprot.writeFieldEnd()
    if self.by_range_param is not None:
      oprot.writeFieldBegin('by_range_param', TType.STRUCT, 2)
      self.by_range_param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.by_hash_param)
    value = (value * 31) ^ hash(self.by_range_param)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduTable:
  """
  Attributes:
   - table_name
   - master_addresses
   - key_columns
   - partition_by
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_name', None, None, ), # 1
    (2, TType.LIST, 'master_addresses', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'key_columns', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'partition_by', (TType.STRUCT,(TKuduPartitionParam, TKuduPartitionParam.thrift_spec)), None, ), # 4
  )

  def __init__(self, table_name=None, master_addresses=None, key_columns=None, partition_by=None,):
    self.table_name = table_name
    self.master_addresses = master_addresses
    self.key_columns = key_columns
    self.partition_by = partition_by

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.master_addresses = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readString()
            self.master_addresses.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.key_columns = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readString()
            self.key_columns.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partition_by = []
          (_etype133, _size130) = iprot.readListBegin()
          for _i134 in xrange(_size130):
            _elem135 = TKuduPartitionParam()
            _elem135.read(iprot)
            self.partition_by.append(_elem135)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduTable')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 1)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.master_addresses is not None:
      oprot.writeFieldBegin('master_addresses', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.master_addresses))
      for iter136 in self.master_addresses:
        oprot.writeString(iter136)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.key_columns is not None:
      oprot.writeFieldBegin('key_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.key_columns))
      for iter137 in self.key_columns:
        oprot.writeString(iter137)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_by is not None:
      oprot.writeFieldBegin('partition_by', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
      for iter138 in self.partition_by:
        iter138.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.master_addresses is None:
      raise TProtocol.TProtocolException(message='Required field master_addresses is unset!')
    if self.key_columns is None:
      raise TProtocol.TProtocolException(message='Required field key_columns is unset!')
    if self.partition_by is None:
      raise TProtocol.TProtocolException(message='Required field partition_by is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.master_addresses)
    value = (value * 31) ^ hash(self.key_columns)
    value = (value * 31) ^ hash(self.partition_by)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTable:
  """
  Attributes:
   - db_name
   - tbl_name
   - load_status
   - access_level
   - columns
   - clustering_columns
   - table_stats
   - table_type
   - hdfs_table
   - hbase_table
   - metastore_table
   - data_source_table
   - kudu_table
   - valid_write_ids
   - storage_metadata_load_time_ns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'load_status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 3
    (4, TType.I32, 'access_level', None, None, ), # 4
    (5, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'clustering_columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 6
    (7, TType.STRUCT, 'table_stats', (TTableStats, TTableStats.thrift_spec), None, ), # 7
    (8, TType.I32, 'table_type', None, None, ), # 8
    (9, TType.STRUCT, 'hdfs_table', (THdfsTable, THdfsTable.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'hbase_table', (THBaseTable, THBaseTable.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'metastore_table', (hive_metastore.ttypes.Table, hive_metastore.ttypes.Table.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'data_source_table', (TDataSourceTable, TDataSourceTable.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'kudu_table', (TKuduTable, TKuduTable.thrift_spec), None, ), # 13
    (14, TType.STRING, 'valid_write_ids', None, None, ), # 14
    (15, TType.I64, 'storage_metadata_load_time_ns', None, None, ), # 15
  )

  def __init__(self, db_name=None, tbl_name=None, load_status=None, access_level=None, columns=None, clustering_columns=None, table_stats=None, table_type=None, hdfs_table=None, hbase_table=None, metastore_table=None, data_source_table=None, kudu_table=None, valid_write_ids=None, storage_metadata_load_time_ns=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.load_status = load_status
    self.access_level = access_level
    self.columns = columns
    self.clustering_columns = clustering_columns
    self.table_stats = table_stats
    self.table_type = table_type
    self.hdfs_table = hdfs_table
    self.hbase_table = hbase_table
    self.metastore_table = metastore_table
    self.data_source_table = data_source_table
    self.kudu_table = kudu_table
    self.valid_write_ids = valid_write_ids
    self.storage_metadata_load_time_ns = storage_metadata_load_time_ns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.load_status = Status.ttypes.TStatus()
          self.load_status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.access_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.columns = []
          (_etype142, _size139) = iprot.readListBegin()
          for _i143 in xrange(_size139):
            _elem144 = TColumn()
            _elem144.read(iprot)
            self.columns.append(_elem144)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.clustering_columns = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = TColumn()
            _elem150.read(iprot)
            self.clustering_columns.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.table_stats = TTableStats()
          self.table_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.table_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.hdfs_table = THdfsTable()
          self.hdfs_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.hbase_table = THBaseTable()
          self.hbase_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.metastore_table = hive_metastore.ttypes.Table()
          self.metastore_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.data_source_table = TDataSourceTable()
          self.data_source_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.kudu_table = TKuduTable()
          self.kudu_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.valid_write_ids = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.storage_metadata_load_time_ns = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTable')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.load_status is not None:
      oprot.writeFieldBegin('load_status', TType.STRUCT, 3)
      self.load_status.write(oprot)
      oprot.writeFieldEnd()
    if self.access_level is not None:
      oprot.writeFieldBegin('access_level', TType.I32, 4)
      oprot.writeI32(self.access_level)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter151 in self.columns:
        iter151.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clustering_columns is not None:
      oprot.writeFieldBegin('clustering_columns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.clustering_columns))
      for iter152 in self.clustering_columns:
        iter152.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.table_stats is not None:
      oprot.writeFieldBegin('table_stats', TType.STRUCT, 7)
      self.table_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.table_type is not None:
      oprot.writeFieldBegin('table_type', TType.I32, 8)
      oprot.writeI32(self.table_type)
      oprot.writeFieldEnd()
    if self.hdfs_table is not None:
      oprot.writeFieldBegin('hdfs_table', TType.STRUCT, 9)
      self.hdfs_table.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_table is not None:
      oprot.writeFieldBegin('hbase_table', TType.STRUCT, 10)
      self.hbase_table.write(oprot)
      oprot.writeFieldEnd()
    if self.metastore_table is not None:
      oprot.writeFieldBegin('metastore_table', TType.STRUCT, 11)
      self.metastore_table.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source_table is not None:
      oprot.writeFieldBegin('data_source_table', TType.STRUCT, 12)
      self.data_source_table.write(oprot)
      oprot.writeFieldEnd()
    if self.kudu_table is not None:
      oprot.writeFieldBegin('kudu_table', TType.STRUCT, 13)
      self.kudu_table.write(oprot)
      oprot.writeFieldEnd()
    if self.valid_write_ids is not None:
      oprot.writeFieldBegin('valid_write_ids', TType.STRING, 14)
      oprot.writeString(self.valid_write_ids)
      oprot.writeFieldEnd()
    if self.storage_metadata_load_time_ns is not None:
      oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 15)
      oprot.writeI64(self.storage_metadata_load_time_ns)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.load_status)
    value = (value * 31) ^ hash(self.access_level)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.clustering_columns)
    value = (value * 31) ^ hash(self.table_stats)
    value = (value * 31) ^ hash(self.table_type)
    value = (value * 31) ^ hash(self.hdfs_table)
    value = (value * 31) ^ hash(self.hbase_table)
    value = (value * 31) ^ hash(self.metastore_table)
    value = (value * 31) ^ hash(self.data_source_table)
    value = (value * 31) ^ hash(self.kudu_table)
    value = (value * 31) ^ hash(self.valid_write_ids)
    value = (value * 31) ^ hash(self.storage_metadata_load_time_ns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDatabase:
  """
  Attributes:
   - db_name
   - metastore_db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRUCT, 'metastore_db', (hive_metastore.ttypes.Database, hive_metastore.ttypes.Database.thrift_spec), None, ), # 2
  )

  def __init__(self, db_name=None, metastore_db=None,):
    self.db_name = db_name
    self.metastore_db = metastore_db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metastore_db = hive_metastore.ttypes.Database()
          self.metastore_db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDatabase')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.metastore_db is not None:
      oprot.writeFieldBegin('metastore_db', TType.STRUCT, 2)
      self.metastore_db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.metastore_db)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrincipal:
  """
  Attributes:
   - principal_name
   - principal_id
   - principal_type
   - grant_groups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_id', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
    (4, TType.LIST, 'grant_groups', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, principal_name=None, principal_id=None, principal_type=None, grant_groups=None,):
    self.principal_name = principal_name
    self.principal_id = principal_id
    self.principal_type = principal_type
    self.grant_groups = grant_groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.grant_groups = []
          (_etype156, _size153) = iprot.readListBegin()
          for _i157 in xrange(_size153):
            _elem158 = iprot.readString()
            self.grant_groups.append(_elem158)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrincipal')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_id is not None:
      oprot.writeFieldBegin('principal_id', TType.I32, 2)
      oprot.writeI32(self.principal_id)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.grant_groups is not None:
      oprot.writeFieldBegin('grant_groups', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.grant_groups))
      for iter159 in self.grant_groups:
        oprot.writeString(iter159)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principal_name is None:
      raise TProtocol.TProtocolException(message='Required field principal_name is unset!')
    if self.principal_id is None:
      raise TProtocol.TProtocolException(message='Required field principal_id is unset!')
    if self.principal_type is None:
      raise TProtocol.TProtocolException(message='Required field principal_type is unset!')
    if self.grant_groups is None:
      raise TProtocol.TProtocolException(message='Required field grant_groups is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_id)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.grant_groups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrivilege:
  """
  Attributes:
   - privilege_level
   - scope
   - has_grant_opt
   - principal_id
   - principal_type
   - server_name
   - db_name
   - table_name
   - uri
   - create_time_ms
   - column_name
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I32, 'privilege_level', None, None, ), # 2
    (3, TType.I32, 'scope', None, None, ), # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ), # 4
    (5, TType.I32, 'principal_id', None, None, ), # 5
    (6, TType.I32, 'principal_type', None, None, ), # 6
    (7, TType.STRING, 'server_name', None, None, ), # 7
    (8, TType.STRING, 'db_name', None, None, ), # 8
    (9, TType.STRING, 'table_name', None, None, ), # 9
    (10, TType.STRING, 'uri', None, None, ), # 10
    (11, TType.I64, 'create_time_ms', None, None, ), # 11
    (12, TType.STRING, 'column_name', None, None, ), # 12
  )

  def __init__(self, privilege_level=None, scope=None, has_grant_opt=None, principal_id=None, principal_type=None, server_name=None, db_name=None, table_name=None, uri=None, create_time_ms=None, column_name=None,):
    self.privilege_level = privilege_level
    self.scope = scope
    self.has_grant_opt = has_grant_opt
    self.principal_id = principal_id
    self.principal_type = principal_type
    self.server_name = server_name
    self.db_name = db_name
    self.table_name = table_name
    self.uri = uri
    self.create_time_ms = create_time_ms
    self.column_name = column_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I32:
          self.privilege_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.scope = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.has_grant_opt = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.principal_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.server_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.uri = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.create_time_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrivilege')
    if self.privilege_level is not None:
      oprot.writeFieldBegin('privilege_level', TType.I32, 2)
      oprot.writeI32(self.privilege_level)
      oprot.writeFieldEnd()
    if self.scope is not None:
      oprot.writeFieldBegin('scope', TType.I32, 3)
      oprot.writeI32(self.scope)
      oprot.writeFieldEnd()
    if self.has_grant_opt is not None:
      oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
      oprot.writeBool(self.has_grant_opt)
      oprot.writeFieldEnd()
    if self.principal_id is not None:
      oprot.writeFieldBegin('principal_id', TType.I32, 5)
      oprot.writeI32(self.principal_id)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 6)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.server_name is not None:
      oprot.writeFieldBegin('server_name', TType.STRING, 7)
      oprot.writeString(self.server_name)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 8)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 9)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 10)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.create_time_ms is not None:
      oprot.writeFieldBegin('create_time_ms', TType.I64, 11)
      oprot.writeI64(self.create_time_ms)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 12)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.privilege_level is None:
      raise TProtocol.TProtocolException(message='Required field privilege_level is unset!')
    if self.scope is None:
      raise TProtocol.TProtocolException(message='Required field scope is unset!')
    if self.has_grant_opt is None:
      raise TProtocol.TProtocolException(message='Required field has_grant_opt is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privilege_level)
    value = (value * 31) ^ hash(self.scope)
    value = (value * 31) ^ hash(self.has_grant_opt)
    value = (value * 31) ^ hash(self.principal_id)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.server_name)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.uri)
    value = (value * 31) ^ hash(self.create_time_ms)
    value = (value * 31) ^ hash(self.column_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsCachePool:
  """
  Attributes:
   - pool_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_name', None, None, ), # 1
  )

  def __init__(self, pool_name=None,):
    self.pool_name = pool_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsCachePool')
    if self.pool_name is not None:
      oprot.writeFieldBegin('pool_name', TType.STRING, 1)
      oprot.writeString(self.pool_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool_name is None:
      raise TProtocol.TProtocolException(message='Required field pool_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAuthzCacheInvalidation:
  """
  Attributes:
   - marker_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'marker_name', None, None, ), # 1
  )

  def __init__(self, marker_name=None,):
    self.marker_name = marker_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.marker_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAuthzCacheInvalidation')
    if self.marker_name is not None:
      oprot.writeFieldBegin('marker_name', TType.STRING, 1)
      oprot.writeString(self.marker_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.marker_name is None:
      raise TProtocol.TProtocolException(message='Required field marker_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.marker_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalog:
  """
  Attributes:
   - catalog_service_id
   - last_reset_catalog_version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.I64, 'last_reset_catalog_version', None, None, ), # 2
  )

  def __init__(self, catalog_service_id=None, last_reset_catalog_version=None,):
    self.catalog_service_id = catalog_service_id
    self.last_reset_catalog_version = last_reset_catalog_version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.last_reset_catalog_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalog')
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    if self.last_reset_catalog_version is not None:
      oprot.writeFieldBegin('last_reset_catalog_version', TType.I64, 2)
      oprot.writeI64(self.last_reset_catalog_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    if self.last_reset_catalog_version is None:
      raise TProtocol.TProtocolException(message='Required field last_reset_catalog_version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catalog_service_id)
    value = (value * 31) ^ hash(self.last_reset_catalog_version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogObject:
  """
  Attributes:
   - type
   - catalog_version
   - catalog
   - db
   - table
   - fn
   - data_source
   - principal
   - privilege
   - cache_pool
   - authz_cache_invalidation
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'catalog_version', None, None, ), # 2
    (3, TType.STRUCT, 'catalog', (TCatalog, TCatalog.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'db', (TDatabase, TDatabase.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'table', (TTable, TTable.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'data_source', (TDataSource, TDataSource.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'principal', (TPrincipal, TPrincipal.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'privilege', (TPrivilege, TPrivilege.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'cache_pool', (THdfsCachePool, THdfsCachePool.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'authz_cache_invalidation', (TAuthzCacheInvalidation, TAuthzCacheInvalidation.thrift_spec), None, ), # 11
  )

  def __init__(self, type=None, catalog_version=None, catalog=None, db=None, table=None, fn=None, data_source=None, principal=None, privilege=None, cache_pool=None, authz_cache_invalidation=None,):
    self.type = type
    self.catalog_version = catalog_version
    self.catalog = catalog
    self.db = db
    self.table = table
    self.fn = fn
    self.data_source = data_source
    self.principal = principal
    self.privilege = privilege
    self.cache_pool = cache_pool
    self.authz_cache_invalidation = authz_cache_invalidation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.catalog_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.catalog = TCatalog()
          self.catalog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.db = TDatabase()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.table = TTable()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.data_source = TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.principal = TPrincipal()
          self.principal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.privilege = TPrivilege()
          self.privilege.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.cache_pool = THdfsCachePool()
          self.cache_pool.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.authz_cache_invalidation = TAuthzCacheInvalidation()
          self.authz_cache_invalidation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogObject')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.catalog_version is not None:
      oprot.writeFieldBegin('catalog_version', TType.I64, 2)
      oprot.writeI64(self.catalog_version)
      oprot.writeFieldEnd()
    if self.catalog is not None:
      oprot.writeFieldBegin('catalog', TType.STRUCT, 3)
      self.catalog.write(oprot)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 4)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 5)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 6)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 7)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.principal is not None:
      oprot.writeFieldBegin('principal', TType.STRUCT, 8)
      self.principal.write(oprot)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRUCT, 9)
      self.privilege.write(oprot)
      oprot.writeFieldEnd()
    if self.cache_pool is not None:
      oprot.writeFieldBegin('cache_pool', TType.STRUCT, 10)
      self.cache_pool.write(oprot)
      oprot.writeFieldEnd()
    if self.authz_cache_invalidation is not None:
      oprot.writeFieldBegin('authz_cache_invalidation', TType.STRUCT, 11)
      self.authz_cache_invalidation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.catalog_version is None:
      raise TProtocol.TProtocolException(message='Required field catalog_version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.catalog_version)
    value = (value * 31) ^ hash(self.catalog)
    value = (value * 31) ^ hash(self.db)
    value = (value * 31) ^ hash(self.table)
    value = (value * 31) ^ hash(self.fn)
    value = (value * 31) ^ hash(self.data_source)
    value = (value * 31) ^ hash(self.principal)
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.cache_pool)
    value = (value * 31) ^ hash(self.authz_cache_invalidation)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
