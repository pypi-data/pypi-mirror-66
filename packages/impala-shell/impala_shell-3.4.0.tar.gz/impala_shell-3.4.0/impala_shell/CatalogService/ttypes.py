#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import CatalogObjects.ttypes
import JniCatalog.ttypes
import Types.ttypes
import Status.ttypes
import Results.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class CatalogServiceVersion:
  V1 = 0

  _VALUES_TO_NAMES = {
    0: "V1",
  }

  _NAMES_TO_VALUES = {
    "V1": 0,
  }

class CatalogLookupStatus:
  OK = 0
  DB_NOT_FOUND = 1
  TABLE_NOT_FOUND = 2
  TABLE_NOT_LOADED = 3
  FUNCTION_NOT_FOUND = 4
  PARTITION_NOT_FOUND = 5

  _VALUES_TO_NAMES = {
    0: "OK",
    1: "DB_NOT_FOUND",
    2: "TABLE_NOT_FOUND",
    3: "TABLE_NOT_LOADED",
    4: "FUNCTION_NOT_FOUND",
    5: "PARTITION_NOT_FOUND",
  }

  _NAMES_TO_VALUES = {
    "OK": 0,
    "DB_NOT_FOUND": 1,
    "TABLE_NOT_FOUND": 2,
    "TABLE_NOT_LOADED": 3,
    "FUNCTION_NOT_FOUND": 4,
    "PARTITION_NOT_FOUND": 5,
  }


class TCatalogServiceRequestHeader:
  """
  Attributes:
   - requesting_user
   - redacted_sql_stmt
   - client_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requesting_user', None, None, ), # 1
    (2, TType.STRING, 'redacted_sql_stmt', None, None, ), # 2
    (3, TType.STRING, 'client_ip', None, None, ), # 3
  )

  def __init__(self, requesting_user=None, redacted_sql_stmt=None, client_ip=None,):
    self.requesting_user = requesting_user
    self.redacted_sql_stmt = redacted_sql_stmt
    self.client_ip = client_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requesting_user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.redacted_sql_stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogServiceRequestHeader')
    if self.requesting_user is not None:
      oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
      oprot.writeString(self.requesting_user)
      oprot.writeFieldEnd()
    if self.redacted_sql_stmt is not None:
      oprot.writeFieldBegin('redacted_sql_stmt', TType.STRING, 2)
      oprot.writeString(self.redacted_sql_stmt)
      oprot.writeFieldEnd()
    if self.client_ip is not None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 3)
      oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requesting_user)
    value = (value * 31) ^ hash(self.redacted_sql_stmt)
    value = (value * 31) ^ hash(self.client_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogUpdateResult:
  """
  Attributes:
   - catalog_service_id
   - version
   - status
   - is_invalidate
   - updated_catalog_objects
   - removed_catalog_objects
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.I64, 'version', None, None, ), # 2
    (3, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'is_invalidate', None, None, ), # 4
    (5, TType.LIST, 'updated_catalog_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'removed_catalog_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 6
  )

  def __init__(self, catalog_service_id=None, version=None, status=None, is_invalidate=None, updated_catalog_objects=None, removed_catalog_objects=None,):
    self.catalog_service_id = catalog_service_id
    self.version = version
    self.status = status
    self.is_invalidate = is_invalidate
    self.updated_catalog_objects = updated_catalog_objects
    self.removed_catalog_objects = removed_catalog_objects

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_invalidate = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.updated_catalog_objects = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = CatalogObjects.ttypes.TCatalogObject()
            _elem5.read(iprot)
            self.updated_catalog_objects.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.removed_catalog_objects = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = CatalogObjects.ttypes.TCatalogObject()
            _elem11.read(iprot)
            self.removed_catalog_objects.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogUpdateResult')
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I64, 2)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.is_invalidate is not None:
      oprot.writeFieldBegin('is_invalidate', TType.BOOL, 4)
      oprot.writeBool(self.is_invalidate)
      oprot.writeFieldEnd()
    if self.updated_catalog_objects is not None:
      oprot.writeFieldBegin('updated_catalog_objects', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_catalog_objects))
      for iter12 in self.updated_catalog_objects:
        iter12.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.removed_catalog_objects is not None:
      oprot.writeFieldBegin('removed_catalog_objects', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.removed_catalog_objects))
      for iter13 in self.removed_catalog_objects:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    if self.is_invalidate is None:
      raise TProtocol.TProtocolException(message='Required field is_invalidate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catalog_service_id)
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.is_invalidate)
    value = (value * 31) ^ hash(self.updated_catalog_objects)
    value = (value * 31) ^ hash(self.removed_catalog_objects)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDdlExecRequest:
  """
  Attributes:
   - protocol_version
   - header
   - ddl_type
   - alter_table_params
   - alter_view_params
   - create_db_params
   - create_table_params
   - create_table_like_params
   - create_view_params
   - create_fn_params
   - drop_db_params
   - drop_table_or_view_params
   - truncate_params
   - drop_fn_params
   - compute_stats_params
   - create_data_source_params
   - drop_data_source_params
   - drop_stats_params
   - create_drop_role_params
   - grant_revoke_role_params
   - grant_revoke_priv_params
   - sync_ddl
   - comment_on_params
   - alter_db_params
   - copy_test_case_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 2
    (3, TType.I32, 'ddl_type', None, None, ), # 3
    (4, TType.STRUCT, 'alter_table_params', (JniCatalog.ttypes.TAlterTableParams, JniCatalog.ttypes.TAlterTableParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'alter_view_params', (JniCatalog.ttypes.TCreateOrAlterViewParams, JniCatalog.ttypes.TCreateOrAlterViewParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'create_db_params', (JniCatalog.ttypes.TCreateDbParams, JniCatalog.ttypes.TCreateDbParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'create_table_params', (JniCatalog.ttypes.TCreateTableParams, JniCatalog.ttypes.TCreateTableParams.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'create_table_like_params', (JniCatalog.ttypes.TCreateTableLikeParams, JniCatalog.ttypes.TCreateTableLikeParams.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'create_view_params', (JniCatalog.ttypes.TCreateOrAlterViewParams, JniCatalog.ttypes.TCreateOrAlterViewParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'create_fn_params', (JniCatalog.ttypes.TCreateFunctionParams, JniCatalog.ttypes.TCreateFunctionParams.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'drop_db_params', (JniCatalog.ttypes.TDropDbParams, JniCatalog.ttypes.TDropDbParams.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'drop_table_or_view_params', (JniCatalog.ttypes.TDropTableOrViewParams, JniCatalog.ttypes.TDropTableOrViewParams.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'truncate_params', (JniCatalog.ttypes.TTruncateParams, JniCatalog.ttypes.TTruncateParams.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'drop_fn_params', (JniCatalog.ttypes.TDropFunctionParams, JniCatalog.ttypes.TDropFunctionParams.thrift_spec), None, ), # 14
    (15, TType.STRUCT, 'compute_stats_params', (JniCatalog.ttypes.TComputeStatsParams, JniCatalog.ttypes.TComputeStatsParams.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'create_data_source_params', (JniCatalog.ttypes.TCreateDataSourceParams, JniCatalog.ttypes.TCreateDataSourceParams.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'drop_data_source_params', (JniCatalog.ttypes.TDropDataSourceParams, JniCatalog.ttypes.TDropDataSourceParams.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'drop_stats_params', (JniCatalog.ttypes.TDropStatsParams, JniCatalog.ttypes.TDropStatsParams.thrift_spec), None, ), # 18
    (19, TType.STRUCT, 'create_drop_role_params', (JniCatalog.ttypes.TCreateDropRoleParams, JniCatalog.ttypes.TCreateDropRoleParams.thrift_spec), None, ), # 19
    (20, TType.STRUCT, 'grant_revoke_role_params', (JniCatalog.ttypes.TGrantRevokeRoleParams, JniCatalog.ttypes.TGrantRevokeRoleParams.thrift_spec), None, ), # 20
    (21, TType.STRUCT, 'grant_revoke_priv_params', (JniCatalog.ttypes.TGrantRevokePrivParams, JniCatalog.ttypes.TGrantRevokePrivParams.thrift_spec), None, ), # 21
    (22, TType.BOOL, 'sync_ddl', None, None, ), # 22
    (23, TType.STRUCT, 'comment_on_params', (JniCatalog.ttypes.TCommentOnParams, JniCatalog.ttypes.TCommentOnParams.thrift_spec), None, ), # 23
    (24, TType.STRUCT, 'alter_db_params', (JniCatalog.ttypes.TAlterDbParams, JniCatalog.ttypes.TAlterDbParams.thrift_spec), None, ), # 24
    (25, TType.STRUCT, 'copy_test_case_params', (JniCatalog.ttypes.TCopyTestCaseReq, JniCatalog.ttypes.TCopyTestCaseReq.thrift_spec), None, ), # 25
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None, ddl_type=None, alter_table_params=None, alter_view_params=None, create_db_params=None, create_table_params=None, create_table_like_params=None, create_view_params=None, create_fn_params=None, drop_db_params=None, drop_table_or_view_params=None, truncate_params=None, drop_fn_params=None, compute_stats_params=None, create_data_source_params=None, drop_data_source_params=None, drop_stats_params=None, create_drop_role_params=None, grant_revoke_role_params=None, grant_revoke_priv_params=None, sync_ddl=None, comment_on_params=None, alter_db_params=None, copy_test_case_params=None,):
    self.protocol_version = protocol_version
    self.header = header
    self.ddl_type = ddl_type
    self.alter_table_params = alter_table_params
    self.alter_view_params = alter_view_params
    self.create_db_params = create_db_params
    self.create_table_params = create_table_params
    self.create_table_like_params = create_table_like_params
    self.create_view_params = create_view_params
    self.create_fn_params = create_fn_params
    self.drop_db_params = drop_db_params
    self.drop_table_or_view_params = drop_table_or_view_params
    self.truncate_params = truncate_params
    self.drop_fn_params = drop_fn_params
    self.compute_stats_params = compute_stats_params
    self.create_data_source_params = create_data_source_params
    self.drop_data_source_params = drop_data_source_params
    self.drop_stats_params = drop_stats_params
    self.create_drop_role_params = create_drop_role_params
    self.grant_revoke_role_params = grant_revoke_role_params
    self.grant_revoke_priv_params = grant_revoke_priv_params
    self.sync_ddl = sync_ddl
    self.comment_on_params = comment_on_params
    self.alter_db_params = alter_db_params
    self.copy_test_case_params = copy_test_case_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ddl_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.alter_table_params = JniCatalog.ttypes.TAlterTableParams()
          self.alter_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.alter_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
          self.alter_view_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.create_db_params = JniCatalog.ttypes.TCreateDbParams()
          self.create_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.create_table_params = JniCatalog.ttypes.TCreateTableParams()
          self.create_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.create_table_like_params = JniCatalog.ttypes.TCreateTableLikeParams()
          self.create_table_like_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.create_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
          self.create_view_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.create_fn_params = JniCatalog.ttypes.TCreateFunctionParams()
          self.create_fn_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.drop_db_params = JniCatalog.ttypes.TDropDbParams()
          self.drop_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.drop_table_or_view_params = JniCatalog.ttypes.TDropTableOrViewParams()
          self.drop_table_or_view_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.truncate_params = JniCatalog.ttypes.TTruncateParams()
          self.truncate_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.drop_fn_params = JniCatalog.ttypes.TDropFunctionParams()
          self.drop_fn_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.compute_stats_params = JniCatalog.ttypes.TComputeStatsParams()
          self.compute_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.create_data_source_params = JniCatalog.ttypes.TCreateDataSourceParams()
          self.create_data_source_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.drop_data_source_params = JniCatalog.ttypes.TDropDataSourceParams()
          self.drop_data_source_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.drop_stats_params = JniCatalog.ttypes.TDropStatsParams()
          self.drop_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.create_drop_role_params = JniCatalog.ttypes.TCreateDropRoleParams()
          self.create_drop_role_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.grant_revoke_role_params = JniCatalog.ttypes.TGrantRevokeRoleParams()
          self.grant_revoke_role_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.grant_revoke_priv_params = JniCatalog.ttypes.TGrantRevokePrivParams()
          self.grant_revoke_priv_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BOOL:
          self.sync_ddl = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.comment_on_params = JniCatalog.ttypes.TCommentOnParams()
          self.comment_on_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRUCT:
          self.alter_db_params = JniCatalog.ttypes.TAlterDbParams()
          self.alter_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.copy_test_case_params = JniCatalog.ttypes.TCopyTestCaseReq()
          self.copy_test_case_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDdlExecRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 2)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    if self.ddl_type is not None:
      oprot.writeFieldBegin('ddl_type', TType.I32, 3)
      oprot.writeI32(self.ddl_type)
      oprot.writeFieldEnd()
    if self.alter_table_params is not None:
      oprot.writeFieldBegin('alter_table_params', TType.STRUCT, 4)
      self.alter_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.alter_view_params is not None:
      oprot.writeFieldBegin('alter_view_params', TType.STRUCT, 5)
      self.alter_view_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_db_params is not None:
      oprot.writeFieldBegin('create_db_params', TType.STRUCT, 6)
      self.create_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_table_params is not None:
      oprot.writeFieldBegin('create_table_params', TType.STRUCT, 7)
      self.create_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_table_like_params is not None:
      oprot.writeFieldBegin('create_table_like_params', TType.STRUCT, 8)
      self.create_table_like_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_view_params is not None:
      oprot.writeFieldBegin('create_view_params', TType.STRUCT, 9)
      self.create_view_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_fn_params is not None:
      oprot.writeFieldBegin('create_fn_params', TType.STRUCT, 10)
      self.create_fn_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_db_params is not None:
      oprot.writeFieldBegin('drop_db_params', TType.STRUCT, 11)
      self.drop_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_table_or_view_params is not None:
      oprot.writeFieldBegin('drop_table_or_view_params', TType.STRUCT, 12)
      self.drop_table_or_view_params.write(oprot)
      oprot.writeFieldEnd()
    if self.truncate_params is not None:
      oprot.writeFieldBegin('truncate_params', TType.STRUCT, 13)
      self.truncate_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_fn_params is not None:
      oprot.writeFieldBegin('drop_fn_params', TType.STRUCT, 14)
      self.drop_fn_params.write(oprot)
      oprot.writeFieldEnd()
    if self.compute_stats_params is not None:
      oprot.writeFieldBegin('compute_stats_params', TType.STRUCT, 15)
      self.compute_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_data_source_params is not None:
      oprot.writeFieldBegin('create_data_source_params', TType.STRUCT, 16)
      self.create_data_source_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_data_source_params is not None:
      oprot.writeFieldBegin('drop_data_source_params', TType.STRUCT, 17)
      self.drop_data_source_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_stats_params is not None:
      oprot.writeFieldBegin('drop_stats_params', TType.STRUCT, 18)
      self.drop_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_drop_role_params is not None:
      oprot.writeFieldBegin('create_drop_role_params', TType.STRUCT, 19)
      self.create_drop_role_params.write(oprot)
      oprot.writeFieldEnd()
    if self.grant_revoke_role_params is not None:
      oprot.writeFieldBegin('grant_revoke_role_params', TType.STRUCT, 20)
      self.grant_revoke_role_params.write(oprot)
      oprot.writeFieldEnd()
    if self.grant_revoke_priv_params is not None:
      oprot.writeFieldBegin('grant_revoke_priv_params', TType.STRUCT, 21)
      self.grant_revoke_priv_params.write(oprot)
      oprot.writeFieldEnd()
    if self.sync_ddl is not None:
      oprot.writeFieldBegin('sync_ddl', TType.BOOL, 22)
      oprot.writeBool(self.sync_ddl)
      oprot.writeFieldEnd()
    if self.comment_on_params is not None:
      oprot.writeFieldBegin('comment_on_params', TType.STRUCT, 23)
      self.comment_on_params.write(oprot)
      oprot.writeFieldEnd()
    if self.alter_db_params is not None:
      oprot.writeFieldBegin('alter_db_params', TType.STRUCT, 24)
      self.alter_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.copy_test_case_params is not None:
      oprot.writeFieldBegin('copy_test_case_params', TType.STRUCT, 25)
      self.copy_test_case_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.ddl_type is None:
      raise TProtocol.TProtocolException(message='Required field ddl_type is unset!')
    if self.sync_ddl is None:
      raise TProtocol.TProtocolException(message='Required field sync_ddl is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.ddl_type)
    value = (value * 31) ^ hash(self.alter_table_params)
    value = (value * 31) ^ hash(self.alter_view_params)
    value = (value * 31) ^ hash(self.create_db_params)
    value = (value * 31) ^ hash(self.create_table_params)
    value = (value * 31) ^ hash(self.create_table_like_params)
    value = (value * 31) ^ hash(self.create_view_params)
    value = (value * 31) ^ hash(self.create_fn_params)
    value = (value * 31) ^ hash(self.drop_db_params)
    value = (value * 31) ^ hash(self.drop_table_or_view_params)
    value = (value * 31) ^ hash(self.truncate_params)
    value = (value * 31) ^ hash(self.drop_fn_params)
    value = (value * 31) ^ hash(self.compute_stats_params)
    value = (value * 31) ^ hash(self.create_data_source_params)
    value = (value * 31) ^ hash(self.drop_data_source_params)
    value = (value * 31) ^ hash(self.drop_stats_params)
    value = (value * 31) ^ hash(self.create_drop_role_params)
    value = (value * 31) ^ hash(self.grant_revoke_role_params)
    value = (value * 31) ^ hash(self.grant_revoke_priv_params)
    value = (value * 31) ^ hash(self.sync_ddl)
    value = (value * 31) ^ hash(self.comment_on_params)
    value = (value * 31) ^ hash(self.alter_db_params)
    value = (value * 31) ^ hash(self.copy_test_case_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDdlExecResponse:
  """
  Attributes:
   - result
   - new_table_created
   - result_set
   - table_name
   - table_create_time
   - table_location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'result', (TCatalogUpdateResult, TCatalogUpdateResult.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'new_table_created', None, None, ), # 2
    (3, TType.STRUCT, 'result_set', (Results.ttypes.TResultSet, Results.ttypes.TResultSet.thrift_spec), None, ), # 3
    (4, TType.STRING, 'table_name', None, None, ), # 4
    (5, TType.I64, 'table_create_time', None, None, ), # 5
    (6, TType.STRING, 'table_location', None, None, ), # 6
  )

  def __init__(self, result=None, new_table_created=None, result_set=None, table_name=None, table_create_time=None, table_location=None,):
    self.result = result
    self.new_table_created = new_table_created
    self.result_set = result_set
    self.table_name = table_name
    self.table_create_time = table_create_time
    self.table_location = table_location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = TCatalogUpdateResult()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.new_table_created = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result_set = Results.ttypes.TResultSet()
          self.result_set.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.table_create_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.table_location = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDdlExecResponse')
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.new_table_created is not None:
      oprot.writeFieldBegin('new_table_created', TType.BOOL, 2)
      oprot.writeBool(self.new_table_created)
      oprot.writeFieldEnd()
    if self.result_set is not None:
      oprot.writeFieldBegin('result_set', TType.STRUCT, 3)
      self.result_set.write(oprot)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 4)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.table_create_time is not None:
      oprot.writeFieldBegin('table_create_time', TType.I64, 5)
      oprot.writeI64(self.table_create_time)
      oprot.writeFieldEnd()
    if self.table_location is not None:
      oprot.writeFieldBegin('table_location', TType.STRING, 6)
      oprot.writeString(self.table_location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result is None:
      raise TProtocol.TProtocolException(message='Required field result is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.new_table_created)
    value = (value * 31) ^ hash(self.result_set)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.table_create_time)
    value = (value * 31) ^ hash(self.table_location)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogRequest:
  """
  Attributes:
   - protocol_version
   - sync_ddl
   - header
   - target_table
   - db_name
   - created_partitions
   - is_overwrite
   - transaction_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.BOOL, 'sync_ddl', None, None, ), # 2
    (3, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 3
    (4, TType.STRING, 'target_table', None, None, ), # 4
    (5, TType.STRING, 'db_name', None, None, ), # 5
    (6, TType.SET, 'created_partitions', (TType.STRING,None), None, ), # 6
    (7, TType.BOOL, 'is_overwrite', None, None, ), # 7
    (8, TType.I64, 'transaction_id', None, None, ), # 8
  )

  def __init__(self, protocol_version=thrift_spec[1][4], sync_ddl=None, header=None, target_table=None, db_name=None, created_partitions=None, is_overwrite=None, transaction_id=None,):
    self.protocol_version = protocol_version
    self.sync_ddl = sync_ddl
    self.header = header
    self.target_table = target_table
    self.db_name = db_name
    self.created_partitions = created_partitions
    self.is_overwrite = is_overwrite
    self.transaction_id = transaction_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.sync_ddl = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.target_table = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.created_partitions = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString()
            self.created_partitions.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.is_overwrite = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.transaction_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.sync_ddl is not None:
      oprot.writeFieldBegin('sync_ddl', TType.BOOL, 2)
      oprot.writeBool(self.sync_ddl)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 3)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    if self.target_table is not None:
      oprot.writeFieldBegin('target_table', TType.STRING, 4)
      oprot.writeString(self.target_table)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 5)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.created_partitions is not None:
      oprot.writeFieldBegin('created_partitions', TType.SET, 6)
      oprot.writeSetBegin(TType.STRING, len(self.created_partitions))
      for iter20 in self.created_partitions:
        oprot.writeString(iter20)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.is_overwrite is not None:
      oprot.writeFieldBegin('is_overwrite', TType.BOOL, 7)
      oprot.writeBool(self.is_overwrite)
      oprot.writeFieldEnd()
    if self.transaction_id is not None:
      oprot.writeFieldBegin('transaction_id', TType.I64, 8)
      oprot.writeI64(self.transaction_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.sync_ddl is None:
      raise TProtocol.TProtocolException(message='Required field sync_ddl is unset!')
    if self.target_table is None:
      raise TProtocol.TProtocolException(message='Required field target_table is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.created_partitions is None:
      raise TProtocol.TProtocolException(message='Required field created_partitions is unset!')
    if self.is_overwrite is None:
      raise TProtocol.TProtocolException(message='Required field is_overwrite is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.sync_ddl)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.target_table)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.created_partitions)
    value = (value * 31) ^ hash(self.is_overwrite)
    value = (value * 31) ^ hash(self.transaction_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'result', (TCatalogUpdateResult, TCatalogUpdateResult.thrift_spec), None, ), # 1
  )

  def __init__(self, result=None,):
    self.result = result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = TCatalogUpdateResult()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogResponse')
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result is None:
      raise TProtocol.TProtocolException(message='Required field result is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.result)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResetMetadataRequest:
  """
  Attributes:
   - protocol_version
   - header
   - is_refresh
   - table_name
   - partition_spec
   - db_name
   - sync_ddl
   - authorization
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_refresh', None, None, ), # 3
    (4, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 4
    (5, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 5
    (6, TType.STRING, 'db_name', None, None, ), # 6
    (7, TType.BOOL, 'sync_ddl', None, None, ), # 7
    (8, TType.BOOL, 'authorization', None, None, ), # 8
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None, is_refresh=None, table_name=None, partition_spec=None, db_name=None, sync_ddl=None, authorization=None,):
    self.protocol_version = protocol_version
    self.header = header
    self.is_refresh = is_refresh
    self.table_name = table_name
    self.partition_spec = partition_spec
    self.db_name = db_name
    self.sync_ddl = sync_ddl
    self.authorization = authorization

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_refresh = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem26.read(iprot)
            self.partition_spec.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.sync_ddl = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.authorization = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResetMetadataRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 2)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    if self.is_refresh is not None:
      oprot.writeFieldBegin('is_refresh', TType.BOOL, 3)
      oprot.writeBool(self.is_refresh)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 4)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter27 in self.partition_spec:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 6)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.sync_ddl is not None:
      oprot.writeFieldBegin('sync_ddl', TType.BOOL, 7)
      oprot.writeBool(self.sync_ddl)
      oprot.writeFieldEnd()
    if self.authorization is not None:
      oprot.writeFieldBegin('authorization', TType.BOOL, 8)
      oprot.writeBool(self.authorization)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.is_refresh is None:
      raise TProtocol.TProtocolException(message='Required field is_refresh is unset!')
    if self.sync_ddl is None:
      raise TProtocol.TProtocolException(message='Required field sync_ddl is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.is_refresh)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.partition_spec)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.sync_ddl)
    value = (value * 31) ^ hash(self.authorization)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResetMetadataResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'result', (TCatalogUpdateResult, TCatalogUpdateResult.thrift_spec), None, ), # 1
  )

  def __init__(self, result=None,):
    self.result = result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = TCatalogUpdateResult()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResetMetadataResponse')
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result is None:
      raise TProtocol.TProtocolException(message='Required field result is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.result)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsRequest:
  """
  Attributes:
   - protocol_version
   - header
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 3
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None, db_name=None,):
    self.protocol_version = protocol_version
    self.header = header
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 3)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.db_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsResponse:
  """
  Attributes:
   - status
   - functions
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.LIST, 'functions', (TType.STRUCT,(Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec)), None, ), # 2
  )

  def __init__(self, status=None, functions=None,):
    self.status = status
    self.functions = functions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.functions = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Types.ttypes.TFunction()
            _elem33.read(iprot)
            self.functions.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.functions is not None:
      oprot.writeFieldBegin('functions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.functions))
      for iter34 in self.functions:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.functions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogInfoSelector:
  """
  Attributes:
   - want_db_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'want_db_names', None, None, ), # 1
  )

  def __init__(self, want_db_names=None,):
    self.want_db_names = want_db_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.want_db_names = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogInfoSelector')
    if self.want_db_names is not None:
      oprot.writeFieldBegin('want_db_names', TType.BOOL, 1)
      oprot.writeBool(self.want_db_names)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.want_db_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartialCatalogInfo:
  """
  Attributes:
   - db_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'db_names', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, db_names=None,):
    self.db_names = db_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.db_names = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readString()
            self.db_names.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartialCatalogInfo')
    if self.db_names is not None:
      oprot.writeFieldBegin('db_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.db_names))
      for iter41 in self.db_names:
        oprot.writeString(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableInfoSelector:
  """
  Attributes:
   - want_hms_table
   - partition_ids
   - want_partition_names
   - want_partition_metadata
   - want_partition_files
   - want_stats_for_column_names
   - want_partition_stats
   - want_table_constraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'want_hms_table', None, None, ), # 1
    (2, TType.LIST, 'partition_ids', (TType.I64,None), None, ), # 2
    (3, TType.BOOL, 'want_partition_names', None, None, ), # 3
    (4, TType.BOOL, 'want_partition_metadata', None, None, ), # 4
    (5, TType.BOOL, 'want_partition_files', None, None, ), # 5
    (6, TType.LIST, 'want_stats_for_column_names', (TType.STRING,None), None, ), # 6
    (7, TType.BOOL, 'want_partition_stats', None, None, ), # 7
    (8, TType.BOOL, 'want_table_constraints', None, None, ), # 8
  )

  def __init__(self, want_hms_table=None, partition_ids=None, want_partition_names=None, want_partition_metadata=None, want_partition_files=None, want_stats_for_column_names=None, want_partition_stats=None, want_table_constraints=None,):
    self.want_hms_table = want_hms_table
    self.partition_ids = partition_ids
    self.want_partition_names = want_partition_names
    self.want_partition_metadata = want_partition_metadata
    self.want_partition_files = want_partition_files
    self.want_stats_for_column_names = want_stats_for_column_names
    self.want_partition_stats = want_partition_stats
    self.want_table_constraints = want_table_constraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.want_hms_table = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_ids = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI64()
            self.partition_ids.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.want_partition_names = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.want_partition_metadata = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.want_partition_files = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.want_stats_for_column_names = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString()
            self.want_stats_for_column_names.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.want_partition_stats = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.want_table_constraints = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableInfoSelector')
    if self.want_hms_table is not None:
      oprot.writeFieldBegin('want_hms_table', TType.BOOL, 1)
      oprot.writeBool(self.want_hms_table)
      oprot.writeFieldEnd()
    if self.partition_ids is not None:
      oprot.writeFieldBegin('partition_ids', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.partition_ids))
      for iter54 in self.partition_ids:
        oprot.writeI64(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.want_partition_names is not None:
      oprot.writeFieldBegin('want_partition_names', TType.BOOL, 3)
      oprot.writeBool(self.want_partition_names)
      oprot.writeFieldEnd()
    if self.want_partition_metadata is not None:
      oprot.writeFieldBegin('want_partition_metadata', TType.BOOL, 4)
      oprot.writeBool(self.want_partition_metadata)
      oprot.writeFieldEnd()
    if self.want_partition_files is not None:
      oprot.writeFieldBegin('want_partition_files', TType.BOOL, 5)
      oprot.writeBool(self.want_partition_files)
      oprot.writeFieldEnd()
    if self.want_stats_for_column_names is not None:
      oprot.writeFieldBegin('want_stats_for_column_names', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.want_stats_for_column_names))
      for iter55 in self.want_stats_for_column_names:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.want_partition_stats is not None:
      oprot.writeFieldBegin('want_partition_stats', TType.BOOL, 7)
      oprot.writeBool(self.want_partition_stats)
      oprot.writeFieldEnd()
    if self.want_table_constraints is not None:
      oprot.writeFieldBegin('want_table_constraints', TType.BOOL, 8)
      oprot.writeBool(self.want_table_constraints)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.want_hms_table)
    value = (value * 31) ^ hash(self.partition_ids)
    value = (value * 31) ^ hash(self.want_partition_names)
    value = (value * 31) ^ hash(self.want_partition_metadata)
    value = (value * 31) ^ hash(self.want_partition_files)
    value = (value * 31) ^ hash(self.want_stats_for_column_names)
    value = (value * 31) ^ hash(self.want_partition_stats)
    value = (value * 31) ^ hash(self.want_table_constraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartialPartitionInfo:
  """
  Attributes:
   - id
   - name
   - hms_partition
   - file_descriptors
   - partition_stats
   - has_incremental_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRUCT, 'hms_partition', (hive_metastore.ttypes.Partition, hive_metastore.ttypes.Partition.thrift_spec), None, ), # 3
    (4, TType.LIST, 'file_descriptors', (TType.STRUCT,(CatalogObjects.ttypes.THdfsFileDesc, CatalogObjects.ttypes.THdfsFileDesc.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'partition_stats', None, None, ), # 5
    (6, TType.BOOL, 'has_incremental_stats', None, None, ), # 6
  )

  def __init__(self, id=None, name=None, hms_partition=None, file_descriptors=None, partition_stats=None, has_incremental_stats=None,):
    self.id = id
    self.name = name
    self.hms_partition = hms_partition
    self.file_descriptors = file_descriptors
    self.partition_stats = partition_stats
    self.has_incremental_stats = has_incremental_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.hms_partition = hive_metastore.ttypes.Partition()
          self.hms_partition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.file_descriptors = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = CatalogObjects.ttypes.THdfsFileDesc()
            _elem61.read(iprot)
            self.file_descriptors.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.partition_stats = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.has_incremental_stats = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartialPartitionInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.hms_partition is not None:
      oprot.writeFieldBegin('hms_partition', TType.STRUCT, 3)
      self.hms_partition.write(oprot)
      oprot.writeFieldEnd()
    if self.file_descriptors is not None:
      oprot.writeFieldBegin('file_descriptors', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.file_descriptors))
      for iter62 in self.file_descriptors:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_stats is not None:
      oprot.writeFieldBegin('partition_stats', TType.STRING, 5)
      oprot.writeString(self.partition_stats)
      oprot.writeFieldEnd()
    if self.has_incremental_stats is not None:
      oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 6)
      oprot.writeBool(self.has_incremental_stats)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.hms_partition)
    value = (value * 31) ^ hash(self.file_descriptors)
    value = (value * 31) ^ hash(self.partition_stats)
    value = (value * 31) ^ hash(self.has_incremental_stats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartialTableInfo:
  """
  Attributes:
   - hms_table
   - partitions
   - column_stats
   - storage_metadata_load_time_ns
   - network_addresses
   - sql_constraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hms_table', (hive_metastore.ttypes.Table, hive_metastore.ttypes.Table.thrift_spec), None, ), # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT,(TPartialPartitionInfo, TPartialPartitionInfo.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'column_stats', (TType.STRUCT,(hive_metastore.ttypes.ColumnStatisticsObj, hive_metastore.ttypes.ColumnStatisticsObj.thrift_spec)), None, ), # 3
    (4, TType.I64, 'storage_metadata_load_time_ns', None, None, ), # 4
    None, # 5
    None, # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT,(Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec)), None, ), # 7
    (8, TType.STRUCT, 'sql_constraints', (SqlConstraints.ttypes.TSqlConstraints, SqlConstraints.ttypes.TSqlConstraints.thrift_spec), None, ), # 8
  )

  def __init__(self, hms_table=None, partitions=None, column_stats=None, storage_metadata_load_time_ns=None, network_addresses=None, sql_constraints=None,):
    self.hms_table = hms_table
    self.partitions = partitions
    self.column_stats = column_stats
    self.storage_metadata_load_time_ns = storage_metadata_load_time_ns
    self.network_addresses = network_addresses
    self.sql_constraints = sql_constraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hms_table = hive_metastore.ttypes.Table()
          self.hms_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = TPartialPartitionInfo()
            _elem68.read(iprot)
            self.partitions.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.column_stats = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = hive_metastore.ttypes.ColumnStatisticsObj()
            _elem74.read(iprot)
            self.column_stats.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.storage_metadata_load_time_ns = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.network_addresses = []
          (_etype78, _size75) = iprot.readListBegin()
          for _i79 in xrange(_size75):
            _elem80 = Types.ttypes.TNetworkAddress()
            _elem80.read(iprot)
            self.network_addresses.append(_elem80)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
          self.sql_constraints.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartialTableInfo')
    if self.hms_table is not None:
      oprot.writeFieldBegin('hms_table', TType.STRUCT, 1)
      self.hms_table.write(oprot)
      oprot.writeFieldEnd()
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter81 in self.partitions:
        iter81.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.column_stats is not None:
      oprot.writeFieldBegin('column_stats', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.column_stats))
      for iter82 in self.column_stats:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.storage_metadata_load_time_ns is not None:
      oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 4)
      oprot.writeI64(self.storage_metadata_load_time_ns)
      oprot.writeFieldEnd()
    if self.network_addresses is not None:
      oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
      for iter83 in self.network_addresses:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sql_constraints is not None:
      oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 8)
      self.sql_constraints.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hms_table)
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.column_stats)
    value = (value * 31) ^ hash(self.storage_metadata_load_time_ns)
    value = (value * 31) ^ hash(self.network_addresses)
    value = (value * 31) ^ hash(self.sql_constraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDbInfoSelector:
  """
  Attributes:
   - want_hms_database
   - want_table_names
   - want_function_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'want_hms_database', None, None, ), # 1
    (2, TType.BOOL, 'want_table_names', None, None, ), # 2
    (3, TType.BOOL, 'want_function_names', None, None, ), # 3
  )

  def __init__(self, want_hms_database=None, want_table_names=None, want_function_names=None,):
    self.want_hms_database = want_hms_database
    self.want_table_names = want_table_names
    self.want_function_names = want_function_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.want_hms_database = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.want_table_names = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.want_function_names = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDbInfoSelector')
    if self.want_hms_database is not None:
      oprot.writeFieldBegin('want_hms_database', TType.BOOL, 1)
      oprot.writeBool(self.want_hms_database)
      oprot.writeFieldEnd()
    if self.want_table_names is not None:
      oprot.writeFieldBegin('want_table_names', TType.BOOL, 2)
      oprot.writeBool(self.want_table_names)
      oprot.writeFieldEnd()
    if self.want_function_names is not None:
      oprot.writeFieldBegin('want_function_names', TType.BOOL, 3)
      oprot.writeBool(self.want_function_names)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.want_hms_database)
    value = (value * 31) ^ hash(self.want_table_names)
    value = (value * 31) ^ hash(self.want_function_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartialDbInfo:
  """
  Attributes:
   - hms_database
   - table_names
   - function_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hms_database', (hive_metastore.ttypes.Database, hive_metastore.ttypes.Database.thrift_spec), None, ), # 1
    (2, TType.LIST, 'table_names', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'function_names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, hms_database=None, table_names=None, function_names=None,):
    self.hms_database = hms_database
    self.table_names = table_names
    self.function_names = function_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hms_database = hive_metastore.ttypes.Database()
          self.hms_database.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.table_names = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = iprot.readString()
            self.table_names.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.function_names = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readString()
            self.function_names.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartialDbInfo')
    if self.hms_database is not None:
      oprot.writeFieldBegin('hms_database', TType.STRUCT, 1)
      self.hms_database.write(oprot)
      oprot.writeFieldEnd()
    if self.table_names is not None:
      oprot.writeFieldBegin('table_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.table_names))
      for iter96 in self.table_names:
        oprot.writeString(iter96)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.function_names is not None:
      oprot.writeFieldBegin('function_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.function_names))
      for iter97 in self.function_names:
        oprot.writeString(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hms_database)
    value = (value * 31) ^ hash(self.table_names)
    value = (value * 31) ^ hash(self.function_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetPartialCatalogObjectRequest:
  """
  Attributes:
   - protocol_version
   - object_desc
   - table_info_selector
   - db_info_selector
   - catalog_info_selector
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'object_desc', (CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'table_info_selector', (TTableInfoSelector, TTableInfoSelector.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'db_info_selector', (TDbInfoSelector, TDbInfoSelector.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'catalog_info_selector', (TCatalogInfoSelector, TCatalogInfoSelector.thrift_spec), None, ), # 5
  )

  def __init__(self, protocol_version=thrift_spec[1][4], object_desc=None, table_info_selector=None, db_info_selector=None, catalog_info_selector=None,):
    self.protocol_version = protocol_version
    self.object_desc = object_desc
    self.table_info_selector = table_info_selector
    self.db_info_selector = db_info_selector
    self.catalog_info_selector = catalog_info_selector

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.object_desc = CatalogObjects.ttypes.TCatalogObject()
          self.object_desc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.table_info_selector = TTableInfoSelector()
          self.table_info_selector.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.db_info_selector = TDbInfoSelector()
          self.db_info_selector.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.catalog_info_selector = TCatalogInfoSelector()
          self.catalog_info_selector.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetPartialCatalogObjectRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.object_desc is not None:
      oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
      self.object_desc.write(oprot)
      oprot.writeFieldEnd()
    if self.table_info_selector is not None:
      oprot.writeFieldBegin('table_info_selector', TType.STRUCT, 3)
      self.table_info_selector.write(oprot)
      oprot.writeFieldEnd()
    if self.db_info_selector is not None:
      oprot.writeFieldBegin('db_info_selector', TType.STRUCT, 4)
      self.db_info_selector.write(oprot)
      oprot.writeFieldEnd()
    if self.catalog_info_selector is not None:
      oprot.writeFieldBegin('catalog_info_selector', TType.STRUCT, 5)
      self.catalog_info_selector.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.object_desc is None:
      raise TProtocol.TProtocolException(message='Required field object_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.object_desc)
    value = (value * 31) ^ hash(self.table_info_selector)
    value = (value * 31) ^ hash(self.db_info_selector)
    value = (value * 31) ^ hash(self.catalog_info_selector)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetPartialCatalogObjectResponse:
  """
  Attributes:
   - status
   - lookup_status
   - object_version_number
   - table_info
   - db_info
   - catalog_info
   - functions
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.I32, 'lookup_status', None,     0, ), # 2
    (3, TType.I64, 'object_version_number', None, None, ), # 3
    (4, TType.STRUCT, 'table_info', (TPartialTableInfo, TPartialTableInfo.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'db_info', (TPartialDbInfo, TPartialDbInfo.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'catalog_info', (TPartialCatalogInfo, TPartialCatalogInfo.thrift_spec), None, ), # 6
    (7, TType.LIST, 'functions', (TType.STRUCT,(Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec)), None, ), # 7
  )

  def __init__(self, status=None, lookup_status=thrift_spec[2][4], object_version_number=None, table_info=None, db_info=None, catalog_info=None, functions=None,):
    self.status = status
    self.lookup_status = lookup_status
    self.object_version_number = object_version_number
    self.table_info = table_info
    self.db_info = db_info
    self.catalog_info = catalog_info
    self.functions = functions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.lookup_status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.object_version_number = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.table_info = TPartialTableInfo()
          self.table_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.db_info = TPartialDbInfo()
          self.db_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.catalog_info = TPartialCatalogInfo()
          self.catalog_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.functions = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = Types.ttypes.TFunction()
            _elem103.read(iprot)
            self.functions.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetPartialCatalogObjectResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.lookup_status is not None:
      oprot.writeFieldBegin('lookup_status', TType.I32, 2)
      oprot.writeI32(self.lookup_status)
      oprot.writeFieldEnd()
    if self.object_version_number is not None:
      oprot.writeFieldBegin('object_version_number', TType.I64, 3)
      oprot.writeI64(self.object_version_number)
      oprot.writeFieldEnd()
    if self.table_info is not None:
      oprot.writeFieldBegin('table_info', TType.STRUCT, 4)
      self.table_info.write(oprot)
      oprot.writeFieldEnd()
    if self.db_info is not None:
      oprot.writeFieldBegin('db_info', TType.STRUCT, 5)
      self.db_info.write(oprot)
      oprot.writeFieldEnd()
    if self.catalog_info is not None:
      oprot.writeFieldBegin('catalog_info', TType.STRUCT, 6)
      self.catalog_info.write(oprot)
      oprot.writeFieldEnd()
    if self.functions is not None:
      oprot.writeFieldBegin('functions', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.functions))
      for iter104 in self.functions:
        iter104.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.lookup_status)
    value = (value * 31) ^ hash(self.object_version_number)
    value = (value * 31) ^ hash(self.table_info)
    value = (value * 31) ^ hash(self.db_info)
    value = (value * 31) ^ hash(self.catalog_info)
    value = (value * 31) ^ hash(self.functions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetCatalogObjectRequest:
  """
  Attributes:
   - protocol_version
   - header
   - object_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'object_desc', (CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 3
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None, object_desc=None,):
    self.protocol_version = protocol_version
    self.header = header
    self.object_desc = object_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.object_desc = CatalogObjects.ttypes.TCatalogObject()
          self.object_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetCatalogObjectRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.object_desc is not None:
      oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
      self.object_desc.write(oprot)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 3)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.object_desc is None:
      raise TProtocol.TProtocolException(message='Required field object_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.object_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetCatalogObjectResponse:
  """
  Attributes:
   - catalog_object
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_object', (CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog_object=None,):
    self.catalog_object = catalog_object

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_object = CatalogObjects.ttypes.TCatalogObject()
          self.catalog_object.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetCatalogObjectResponse')
    if self.catalog_object is not None:
      oprot.writeFieldBegin('catalog_object', TType.STRUCT, 1)
      self.catalog_object.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_object is None:
      raise TProtocol.TProtocolException(message='Required field catalog_object is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catalog_object)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetPartitionStatsRequest:
  """
  Attributes:
   - protocol_version
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
  )

  def __init__(self, protocol_version=thrift_spec[1][4], table_name=None,):
    self.protocol_version = protocol_version
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetPartitionStatsRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetPartitionStatsResponse:
  """
  Attributes:
   - status
   - partition_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.MAP, 'partition_stats', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, status=None, partition_stats=None,):
    self.status = status
    self.partition_stats = partition_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.partition_stats = {}
          (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin()
          for _i109 in xrange(_size105):
            _key110 = iprot.readString()
            _val111 = iprot.readString()
            self.partition_stats[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetPartitionStatsResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_stats is not None:
      oprot.writeFieldBegin('partition_stats', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partition_stats))
      for kiter112,viter113 in self.partition_stats.items():
        oprot.writeString(kiter112)
        oprot.writeString(viter113)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.partition_stats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrioritizeLoadRequest:
  """
  Attributes:
   - protocol_version
   - header
   - object_descs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 2
    (3, TType.LIST, 'object_descs', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 3
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None, object_descs=None,):
    self.protocol_version = protocol_version
    self.header = header
    self.object_descs = object_descs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.object_descs = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = CatalogObjects.ttypes.TCatalogObject()
            _elem119.read(iprot)
            self.object_descs.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrioritizeLoadRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 2)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    if self.object_descs is not None:
      oprot.writeFieldBegin('object_descs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.object_descs))
      for iter120 in self.object_descs:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    if self.object_descs is None:
      raise TProtocol.TProtocolException(message='Required field object_descs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    value = (value * 31) ^ hash(self.object_descs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrioritizeLoadResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrioritizeLoadResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSentryAdminCheckRequest:
  """
  Attributes:
   - protocol_version
   - header
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None,     0, ), # 1
    (2, TType.STRUCT, 'header', (TCatalogServiceRequestHeader, TCatalogServiceRequestHeader.thrift_spec), None, ), # 2
  )

  def __init__(self, protocol_version=thrift_spec[1][4], header=None,):
    self.protocol_version = protocol_version
    self.header = header

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.header = TCatalogServiceRequestHeader()
          self.header.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSentryAdminCheckRequest')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.header is not None:
      oprot.writeFieldBegin('header', TType.STRUCT, 2)
      self.header.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.protocol_version)
    value = (value * 31) ^ hash(self.header)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSentryAdminCheckResponse:
  """
  Attributes:
   - status
   - is_admin
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'is_admin', None, None, ), # 2
  )

  def __init__(self, status=None, is_admin=None,):
    self.status = status
    self.is_admin = is_admin

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_admin = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSentryAdminCheckResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.is_admin is not None:
      oprot.writeFieldBegin('is_admin', TType.BOOL, 2)
      oprot.writeBool(self.is_admin)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_admin is None:
      raise TProtocol.TProtocolException(message='Required field is_admin is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.is_admin)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableUsage:
  """
  Attributes:
   - table_name
   - num_usages
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.I32, 'num_usages', None, None, ), # 2
  )

  def __init__(self, table_name=None, num_usages=None,):
    self.table_name = table_name
    self.num_usages = num_usages

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.num_usages = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableUsage')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.num_usages is not None:
      oprot.writeFieldBegin('num_usages', TType.I32, 2)
      oprot.writeI32(self.num_usages)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.num_usages is None:
      raise TProtocol.TProtocolException(message='Required field num_usages is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.num_usages)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateTableUsageRequest:
  """
  Attributes:
   - usages
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'usages', (TType.STRUCT,(TTableUsage, TTableUsage.thrift_spec)), None, ), # 1
  )

  def __init__(self, usages=None,):
    self.usages = usages

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.usages = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = TTableUsage()
            _elem126.read(iprot)
            self.usages.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateTableUsageRequest')
    if self.usages is not None:
      oprot.writeFieldBegin('usages', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.usages))
      for iter127 in self.usages:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.usages is None:
      raise TProtocol.TProtocolException(message='Required field usages is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.usages)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateTableUsageResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateTableUsageResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
