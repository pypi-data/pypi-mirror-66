Metadata-Version: 2.1
Name: tiny-3d-engine
Version: 0.1.0
Summary: Open Source tiny 3D engine for tkinter
Home-page: http://cerfacs.fr/coop/
Author: Antoine Dauptain
Author-email: coop@cerfacs.com
License: CeCILL-B FREE SOFTWARE LICENSE AGREEMENT
Keywords: 3D,python,Tkinter
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Description-Content-Type: text/markdown
Requires-Dist: numpy

# Tiny 3D Engine

![logo](http://cerfacs.fr/coop/whatwedo/logo_tiny3dengine.gif)

This package is a python 3D engine based on the Tkinter Canvas.
It uses Numpy for math handling.

*It is available on [pipy](https://pypi.org/project/tiny-3d-engine/), 
documentation is on [readtthedocs](https://tiny-3d-engine.readthedocs.io/en/latest/), sources are mirrored on [gitlab.com](https://gitlab.com/cerfacs/tiny_3d_engine)*

Install this using 

```bash
pip install tiny_3d_engine
```


It create simle 3D rendering for `bars`, `tri` and `quad` elements and store the scenes in Ensight's ASCII `.geo`format.
A trivial square would look like:

![trivial_example](http://cerfacs.fr/coop/whatwedo/example_t3e.png)

## example

In the following example, two squares are appended to an initially void **Scene3D** object.

- The first, in blue, is made of edges (2 vertices connectivity)
- The second, in red, is made od squares (4 vertices connectivity)

This scene is passed to the **Engine3D** object, triggering a window.

```python
from tiny_3d_engine import (Scene3D, Engine3D)

scene = Scene3D()

SIZE = 2
LENGTH= 200.
points = list()
conn = list()
dx = LENGTH/

for i in range(SIZE):
    for j in range(SIZE):
        index = len(points)
        points.append([i*dx, j*dx, 0])
        points.append([(i+1)*dx, j*dx, 0])
        points.append([i*dx, (j+1)*dx, 0])
        points.append([(i+1)*dx, (j+1)*dx, 0])
        #conn.append([index, index+1, index+2])
        #conn.append([index+3, index+1, index+2])
        conn.append([index, index+1])
        conn.append([index+3, index+1])
scene.add_or_update_part("square1", points, conn, color="#0000ff")

points = list()
conn = list()
for i in range(SIZE):
    for j in range(SIZE):
        index = len(points)
        points.append([i*dx, j*dx, LENGTH])
        points.append([(i+1)*dx, j*dx, LENGTH])
        points.append([i*dx, (j+1)*dx, LENGTH])
        points.append([(i+1)*dx, (j+1)*dx, LENGTH])
        conn.append([index, index+1, index+3, index+2])
scene.add_or_update_part("square2", points, conn, color="#ff0000")

test = Engine3D(scene)
test.rotate("x", 45)
test.rotate("y", 45)
test.render()
#test.bench_speed()
test.mainloop()

```

## requirements

The present library require Numpy and Tkinter. 
The Tk aspects are limited to the **screen** object.
In the future I might write extensions for PyQT4 Canvas or Matplotlib... or not.

## origin

It is a mix between a Pure Tcl/Tk Engine of mine [pureTK 3d engine](https://gitlab.com/cerfacs/opentea/blob/1.7/c3sm/create_viewer3d.tcl) and the the pyEngine3D-master of [henryHaefliger](https://github.com/hnhaefliger)[pyEngine3D](https://github.com/hnhaefliger/PyEngine3D) , because I really liked the API.

The present one allow several parts to be loaded, and uses numpy.
Scenes can be dumped or read from the Ensight .case/.geo files.


